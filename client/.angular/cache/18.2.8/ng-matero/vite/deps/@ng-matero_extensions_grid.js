import {
  MtxDialog,
  MtxDialogModule
} from "./chunk-25DK2IX3.js";
import {
  MtxIsTemplateRefPipe,
  MtxPipesModule,
  MtxToObservablePipe
} from "./chunk-VMQW4LMA.js";
import {
  MatCell,
  MatCellDef,
  MatColumnDef,
  MatFooterCell,
  MatFooterCellDef,
  MatFooterRow,
  MatFooterRowDef,
  MatHeaderCell,
  MatHeaderCellDef,
  MatHeaderRow,
  MatHeaderRowDef,
  MatRow,
  MatRowDef,
  MatTable,
  MatTableDataSource,
  MatTableModule
} from "./chunk-EQFKGD2J.js";
import {
  MatSort,
  MatSortHeader,
  MatSortModule
} from "./chunk-O7YSCWEI.js";
import {
  MatIcon,
  MatIconModule
} from "./chunk-DRN4REPK.js";
import "./chunk-65H4I3RJ.js";
import {
  MatProgressBar,
  MatProgressBarModule
} from "./chunk-EBMUPTIJ.js";
import {
  MatMenu,
  MatMenuItem,
  MatMenuModule,
  MatMenuTrigger
} from "./chunk-ZO34UI4E.js";
import {
  MatPaginator,
  MatPaginatorModule
} from "./chunk-26ZSG7M5.js";
import {
  MatTooltip,
  MatTooltipModule
} from "./chunk-3ZCR5HXG.js";
import {
  MatSelectModule
} from "./chunk-ZPDPHEFL.js";
import {
  MatCheckbox,
  MatCheckboxModule
} from "./chunk-KFDTBRMB.js";
import {
  MatChip,
  MatChipListbox,
  MatChipsModule
} from "./chunk-HPJNJ4KT.js";
import "./chunk-LVEZNUUG.js";
import {
  MatButton,
  MatButtonModule,
  MatFabButton,
  MatIconButton,
  MatMiniFabButton
} from "./chunk-O3D5ZRSY.js";
import {
  MatFormFieldModule
} from "./chunk-GJ36CECM.js";
import "./chunk-7MGLFPMK.js";
import {
  MatBadge,
  MatBadgeModule
} from "./chunk-MFJPDDMP.js";
import "./chunk-2MP7MOE4.js";
import {
  Overlay,
  OverlayModule
} from "./chunk-W4QSE2MO.js";
import {
  ComponentPortal
} from "./chunk-RRYMOHQ3.js";
import {
  FormsModule,
  NgControlStatus,
  NgModel
} from "./chunk-5C5M6BN6.js";
import {
  MatCommonModule
} from "./chunk-HBP6OA6Q.js";
import {
  animate,
  state,
  style,
  transition,
  trigger
} from "./chunk-IPQJSEC4.js";
import {
  CdkColumnDef,
  CdkTable,
  _COALESCED_STYLE_SCHEDULER,
  _CoalescedStyleScheduler
} from "./chunk-ZLRU3MKM.js";
import {
  CdkDrag,
  CdkDropList,
  DragDropModule,
  moveItemInArray
} from "./chunk-YPO43JZN.js";
import {
  ESCAPE
} from "./chunk-U7VVEHQ6.js";
import "./chunk-5SQMXRTA.js";
import "./chunk-2NPGNF2M.js";
import {
  SelectionModel
} from "./chunk-X7CATLYX.js";
import {
  Directionality
} from "./chunk-SWKTGBAV.js";
import {
  coerceCssPixelValue
} from "./chunk-5DDL3Q73.js";
import "./chunk-6FVM5ZDU.js";
import {
  AsyncPipe,
  CommonModule,
  CurrencyPipe,
  DOCUMENT,
  DatePipe,
  DecimalPipe,
  NgTemplateOutlet,
  PercentPipe
} from "./chunk-R3EXXSPB.js";
import {
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  KeyValueDiffers,
  NgModule,
  NgZone,
  Optional,
  Output,
  Pipe,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation$1,
  booleanAttribute,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵpipeBind4,
  ɵɵpipeBindV,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-57TCTXNO.js";
import {
  fromEvent,
  isObservable,
  merge
} from "./chunk-O6VDDHVS.js";
import "./chunk-IXUSS67I.js";
import {
  Observable,
  Subject,
  combineLatest,
  distinctUntilChanged,
  filter,
  map,
  mapTo,
  pairwise,
  share,
  skip,
  startWith,
  take,
  takeUntil
} from "./chunk-BONRK7YY.js";
import "./chunk-PEHFQLBM.js";

// node_modules/@ng-matero/extensions/fesm2022/mtxColumnResize.mjs
var HEADER_CELL_SELECTOR = ".cdk-header-cell, .mat-header-cell";
var HEADER_ROW_SELECTOR = ".cdk-header-row, .mat-header-row";
var RESIZE_OVERLAY_SELECTOR = ".mat-column-resize-overlay-thumb";
function closest(element, selector) {
  if (!(element instanceof Node)) {
    return null;
  }
  let curr = element;
  while (curr != null && !(curr instanceof Element)) {
    curr = curr.parentNode;
  }
  return curr?.closest(selector) ?? null;
}
var HOVER_OR_ACTIVE_CLASS = "cdk-column-resize-hover-or-active";
var WITH_RESIZED_COLUMN_CLASS = "cdk-column-resize-with-resized-column";
var nextId = 0;
var ColumnResize = class _ColumnResize {
  constructor() {
    this.destroyed = new Subject();
    this.selectorId = `${++nextId}`;
  }
  ngAfterViewInit() {
    this.elementRef.nativeElement.classList.add(this.getUniqueCssClass());
    this._listenForRowHoverEvents();
    this._listenForResizeActivity();
    this._listenForHoverActivity();
  }
  ngOnDestroy() {
    this.destroyed.next();
    this.destroyed.complete();
  }
  /** Gets the unique CSS class name for this table instance. */
  getUniqueCssClass() {
    return `cdk-column-resize-${this.selectorId}`;
  }
  /** Called when a column in the table is resized. Applies a css class to the table element. */
  setResized() {
    this.elementRef.nativeElement.classList.add(WITH_RESIZED_COLUMN_CLASS);
  }
  _listenForRowHoverEvents() {
    this.ngZone.runOutsideAngular(() => {
      const element = this.elementRef.nativeElement;
      fromEvent(element, "mouseover").pipe(map((event) => closest(event.target, HEADER_CELL_SELECTOR)), takeUntil(this.destroyed)).subscribe(this.eventDispatcher.headerCellHovered);
      fromEvent(element, "mouseleave").pipe(filter((event) => !!event.relatedTarget && !event.relatedTarget.matches(RESIZE_OVERLAY_SELECTOR)), mapTo(null), takeUntil(this.destroyed)).subscribe(this.eventDispatcher.headerCellHovered);
    });
  }
  _listenForResizeActivity() {
    merge(this.eventDispatcher.overlayHandleActiveForCell.pipe(mapTo(void 0)), this.notifier.triggerResize.pipe(mapTo(void 0)), this.notifier.resizeCompleted.pipe(mapTo(void 0))).pipe(take(1), takeUntil(this.destroyed)).subscribe(() => {
      this.setResized();
    });
  }
  _listenForHoverActivity() {
    this.eventDispatcher.headerRowHoveredOrActiveDistinct.pipe(startWith(null), pairwise(), takeUntil(this.destroyed)).subscribe(([previousRow, hoveredRow]) => {
      if (hoveredRow) {
        hoveredRow.classList.add(HOVER_OR_ACTIVE_CLASS);
      }
      if (previousRow) {
        previousRow.classList.remove(HOVER_OR_ACTIVE_CLASS);
      }
    });
  }
  static {
    this.ɵfac = function ColumnResize_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ColumnResize)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _ColumnResize
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResize, [{
    type: Directive
  }], null, null);
})();
var ColumnResizeNotifierSource = class _ColumnResizeNotifierSource {
  constructor() {
    this.resizeCanceled = new Subject();
    this.resizeCompleted = new Subject();
    this.triggerResize = new Subject();
  }
  static {
    this.ɵfac = function ColumnResizeNotifierSource_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ColumnResizeNotifierSource)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ColumnResizeNotifierSource,
      factory: _ColumnResizeNotifierSource.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizeNotifierSource, [{
    type: Injectable
  }], null, null);
})();
var ColumnResizeNotifier = class _ColumnResizeNotifier {
  constructor(_source) {
    this._source = _source;
    this.resizeCompleted = this._source.resizeCompleted;
  }
  /** Instantly resizes the specified column. */
  resize(columnId, size) {
    this._source.triggerResize.next({
      columnId,
      size,
      completeImmediately: true,
      isStickyColumn: true
    });
  }
  static {
    this.ɵfac = function ColumnResizeNotifier_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ColumnResizeNotifier)(ɵɵinject(ColumnResizeNotifierSource));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ColumnResizeNotifier,
      factory: _ColumnResizeNotifier.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizeNotifier, [{
    type: Injectable
  }], () => [{
    type: ColumnResizeNotifierSource
  }], null);
})();
var HeaderRowEventDispatcher = class _HeaderRowEventDispatcher {
  constructor(_ngZone) {
    this._ngZone = _ngZone;
    this.headerCellHovered = new Subject();
    this.overlayHandleActiveForCell = new Subject();
    this.headerCellHoveredDistinct = this.headerCellHovered.pipe(distinctUntilChanged(), share());
    this.headerRowHoveredOrActiveDistinct = combineLatest([this.headerCellHoveredDistinct.pipe(map((cell) => closest(cell, HEADER_ROW_SELECTOR)), startWith(null), distinctUntilChanged()), this.overlayHandleActiveForCell.pipe(map((cell) => closest(cell, HEADER_ROW_SELECTOR)), startWith(null), distinctUntilChanged())]).pipe(
      skip(1),
      // Ignore initial [null, null] emission.
      map(([hovered, active]) => active || hovered),
      distinctUntilChanged(),
      share()
    );
    this._headerRowHoveredOrActiveDistinctReenterZone = this.headerRowHoveredOrActiveDistinct.pipe(this._enterZone(), share());
    this._lastSeenRow = null;
    this._lastSeenRowHover = null;
  }
  /**
   * Emits whether the specified row should show its overlay controls.
   * Emission occurs within the NgZone.
   */
  resizeOverlayVisibleForHeaderRow(row) {
    if (row !== this._lastSeenRow) {
      this._lastSeenRow = row;
      this._lastSeenRowHover = this._headerRowHoveredOrActiveDistinctReenterZone.pipe(map((hoveredRow) => hoveredRow === row), distinctUntilChanged(), share());
    }
    return this._lastSeenRowHover;
  }
  _enterZone() {
    return (source) => new Observable((observer) => source.subscribe({
      next: (value) => this._ngZone.run(() => observer.next(value)),
      error: (err) => observer.error(err),
      complete: () => observer.complete()
    }));
  }
  static {
    this.ɵfac = function HeaderRowEventDispatcher_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HeaderRowEventDispatcher)(ɵɵinject(NgZone));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HeaderRowEventDispatcher,
      factory: _HeaderRowEventDispatcher.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderRowEventDispatcher, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var ResizeStrategy = class _ResizeStrategy {
  constructor() {
    this._pendingResizeDelta = null;
  }
  /** Adjusts the width of the table element by the specified delta. */
  updateTableWidthAndStickyColumns(delta) {
    if (this._pendingResizeDelta === null) {
      const tableElement = this.columnResize.elementRef.nativeElement;
      const tableWidth = getElementWidth(tableElement);
      this.styleScheduler.schedule(() => {
        tableElement.style.width = coerceCssPixelValue(tableWidth + this._pendingResizeDelta);
        this._pendingResizeDelta = null;
      });
      this.styleScheduler.scheduleEnd(() => {
        this.table.updateStickyColumnStyles();
      });
    }
    this._pendingResizeDelta = (this._pendingResizeDelta ?? 0) + delta;
  }
  static {
    this.ɵfac = function ResizeStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ResizeStrategy)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ResizeStrategy,
      factory: _ResizeStrategy.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeStrategy, [{
    type: Injectable
  }], null, null);
})();
var TableLayoutFixedResizeStrategy = class _TableLayoutFixedResizeStrategy extends ResizeStrategy {
  constructor(columnResize, styleScheduler, table) {
    super();
    this.columnResize = columnResize;
    this.styleScheduler = styleScheduler;
    this.table = table;
  }
  applyColumnSize(_, columnHeader, sizeInPx, previousSizeInPx) {
    const delta = sizeInPx - (previousSizeInPx ?? getElementWidth(columnHeader));
    if (delta === 0) {
      return;
    }
    this.styleScheduler.schedule(() => {
      columnHeader.style.width = coerceCssPixelValue(sizeInPx);
    });
    this.updateTableWidthAndStickyColumns(delta);
  }
  applyMinColumnSize(_, columnHeader, sizeInPx) {
    const currentWidth = getElementWidth(columnHeader);
    const newWidth = Math.max(currentWidth, sizeInPx);
    this.applyColumnSize(_, columnHeader, newWidth, currentWidth);
  }
  applyMaxColumnSize(_, columnHeader, sizeInPx) {
    const currentWidth = getElementWidth(columnHeader);
    const newWidth = Math.min(currentWidth, sizeInPx);
    this.applyColumnSize(_, columnHeader, newWidth, currentWidth);
  }
  static {
    this.ɵfac = function TableLayoutFixedResizeStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TableLayoutFixedResizeStrategy)(ɵɵinject(ColumnResize), ɵɵinject(_COALESCED_STYLE_SCHEDULER), ɵɵinject(CdkTable));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TableLayoutFixedResizeStrategy,
      factory: _TableLayoutFixedResizeStrategy.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableLayoutFixedResizeStrategy, [{
    type: Injectable
  }], () => [{
    type: ColumnResize
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: CdkTable
  }], null);
})();
var CdkFlexTableResizeStrategy = class _CdkFlexTableResizeStrategy extends ResizeStrategy {
  constructor(columnResize, styleScheduler, table, document, _nonce) {
    super();
    this.columnResize = columnResize;
    this.styleScheduler = styleScheduler;
    this.table = table;
    this._nonce = _nonce;
    this._columnIndexes = /* @__PURE__ */ new Map();
    this._columnProperties = /* @__PURE__ */ new Map();
    this._indexSequence = 0;
    this.defaultMinSize = 0;
    this.defaultMaxSize = Number.MAX_SAFE_INTEGER;
    this._document = document;
  }
  applyColumnSize(cssFriendlyColumnName, columnHeader, sizeInPx, previousSizeInPx) {
    const delta = sizeInPx - (previousSizeInPx ?? (this._getAppliedWidth(cssFriendlyColumnName) || columnHeader.offsetWidth));
    if (delta === 0) {
      return;
    }
    const cssSize = coerceCssPixelValue(sizeInPx);
    this._applyProperty(cssFriendlyColumnName, "flex", `0 0.01 ${cssSize}`);
    this.updateTableWidthAndStickyColumns(delta);
  }
  applyMinColumnSize(cssFriendlyColumnName, _, sizeInPx) {
    const cssSize = coerceCssPixelValue(sizeInPx);
    this._applyProperty(cssFriendlyColumnName, "min-width", cssSize, sizeInPx !== this.defaultMinSize);
    this.updateTableWidthAndStickyColumns(0);
  }
  applyMaxColumnSize(cssFriendlyColumnName, _, sizeInPx) {
    const cssSize = coerceCssPixelValue(sizeInPx);
    this._applyProperty(cssFriendlyColumnName, "max-width", cssSize, sizeInPx !== this.defaultMaxSize);
    this.updateTableWidthAndStickyColumns(0);
  }
  getColumnCssClass(cssFriendlyColumnName) {
    return `cdk-column-${cssFriendlyColumnName}`;
  }
  ngOnDestroy() {
    this._styleElement?.remove();
    this._styleElement = void 0;
  }
  _getPropertyValue(cssFriendlyColumnName, key) {
    const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
    return properties.get(key);
  }
  _getAppliedWidth(cssFriendslyColumnName) {
    return coercePixelsFromFlexValue(this._getPropertyValue(cssFriendslyColumnName, "flex"));
  }
  _applyProperty(cssFriendlyColumnName, key, value, enable = true) {
    const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
    this.styleScheduler.schedule(() => {
      if (enable) {
        properties.set(key, value);
      } else {
        properties.delete(key);
      }
      this._applySizeCss(cssFriendlyColumnName);
    });
  }
  _getStyleSheet() {
    if (!this._styleElement) {
      this._styleElement = this._document.createElement("style");
      if (this._nonce) {
        this._styleElement.nonce = this._nonce;
      }
      this._styleElement.appendChild(this._document.createTextNode(""));
      this._document.head.appendChild(this._styleElement);
    }
    return this._styleElement.sheet;
  }
  _getColumnPropertiesMap(cssFriendlyColumnName) {
    let properties = this._columnProperties.get(cssFriendlyColumnName);
    if (properties === void 0) {
      properties = /* @__PURE__ */ new Map();
      this._columnProperties.set(cssFriendlyColumnName, properties);
    }
    return properties;
  }
  _applySizeCss(cssFriendlyColumnName) {
    const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
    const propertyKeys = Array.from(properties.keys());
    let index = this._columnIndexes.get(cssFriendlyColumnName);
    if (index === void 0) {
      if (!propertyKeys.length) {
        return;
      }
      index = this._indexSequence++;
      this._columnIndexes.set(cssFriendlyColumnName, index);
    } else {
      this._getStyleSheet().deleteRule(index);
    }
    const columnClassName = this.getColumnCssClass(cssFriendlyColumnName);
    const tableClassName = this.columnResize.getUniqueCssClass();
    const selector = `.${tableClassName} .${columnClassName}`;
    const body = propertyKeys.map((key) => `${key}:${properties.get(key)}`).join(";");
    this._getStyleSheet().insertRule(`${selector} {${body}}`, index);
  }
  static {
    this.ɵfac = function CdkFlexTableResizeStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CdkFlexTableResizeStrategy)(ɵɵinject(ColumnResize), ɵɵinject(_COALESCED_STYLE_SCHEDULER), ɵɵinject(CdkTable), ɵɵinject(DOCUMENT), ɵɵinject(CSP_NONCE, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _CdkFlexTableResizeStrategy,
      factory: _CdkFlexTableResizeStrategy.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFlexTableResizeStrategy, [{
    type: Injectable
  }], () => [{
    type: ColumnResize
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: CdkTable
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }, {
      type: Optional
    }]
  }], null);
})();
function coercePixelsFromCssValue(cssValue) {
  return Number(cssValue.match(/(\d+)px/)?.[1]);
}
function getElementWidth(element) {
  return coercePixelsFromCssValue(element.style.width) || element.offsetWidth;
}
function coercePixelsFromFlexValue(flexValue) {
  return Number(flexValue?.match(/0 0\.01 (\d+)px/)?.[1]);
}
var TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER = {
  provide: ResizeStrategy,
  useClass: TableLayoutFixedResizeStrategy
};
var FLEX_RESIZE_STRATEGY_PROVIDER = {
  provide: ResizeStrategy,
  useClass: CdkFlexTableResizeStrategy
};
var PROVIDERS = [ColumnResizeNotifier, HeaderRowEventDispatcher, ColumnResizeNotifierSource];
var TABLE_PROVIDERS = [...PROVIDERS, TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER];
var FLEX_PROVIDERS = [...PROVIDERS, FLEX_RESIZE_STRATEGY_PROVIDER];
var CdkColumnResize = class _CdkColumnResize extends ColumnResize {
  constructor(columnResizeNotifier, elementRef, eventDispatcher, ngZone, notifier, table) {
    super();
    this.columnResizeNotifier = columnResizeNotifier;
    this.elementRef = elementRef;
    this.eventDispatcher = eventDispatcher;
    this.ngZone = ngZone;
    this.notifier = notifier;
    this.table = table;
  }
  static {
    this.ɵfac = function CdkColumnResize_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CdkColumnResize)(ɵɵdirectiveInject(ColumnResizeNotifier), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(HeaderRowEventDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ColumnResizeNotifierSource), ɵɵdirectiveInject(CdkTable));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkColumnResize,
      selectors: [["table", "cdk-table", "", "columnResize", ""]],
      standalone: true,
      features: [ɵɵProvidersFeature([...TABLE_PROVIDERS, {
        provide: ColumnResize,
        useExisting: _CdkColumnResize
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnResize, [{
    type: Directive,
    args: [{
      selector: "table[cdk-table][columnResize]",
      providers: [...TABLE_PROVIDERS, {
        provide: ColumnResize,
        useExisting: CdkColumnResize
      }],
      standalone: true
    }]
  }], () => [{
    type: ColumnResizeNotifier
  }, {
    type: ElementRef
  }, {
    type: HeaderRowEventDispatcher
  }, {
    type: NgZone
  }, {
    type: ColumnResizeNotifierSource
  }, {
    type: CdkTable
  }], null);
})();
var CdkColumnResizeFlex = class _CdkColumnResizeFlex extends ColumnResize {
  constructor(columnResizeNotifier, elementRef, eventDispatcher, ngZone, notifier, table) {
    super();
    this.columnResizeNotifier = columnResizeNotifier;
    this.elementRef = elementRef;
    this.eventDispatcher = eventDispatcher;
    this.ngZone = ngZone;
    this.notifier = notifier;
    this.table = table;
  }
  static {
    this.ɵfac = function CdkColumnResizeFlex_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CdkColumnResizeFlex)(ɵɵdirectiveInject(ColumnResizeNotifier), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(HeaderRowEventDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ColumnResizeNotifierSource), ɵɵdirectiveInject(CdkTable));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkColumnResizeFlex,
      selectors: [["cdk-table", "columnResize", ""]],
      standalone: true,
      features: [ɵɵProvidersFeature([...FLEX_PROVIDERS, {
        provide: ColumnResize,
        useExisting: _CdkColumnResizeFlex
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnResizeFlex, [{
    type: Directive,
    args: [{
      selector: "cdk-table[columnResize]",
      providers: [...FLEX_PROVIDERS, {
        provide: ColumnResize,
        useExisting: CdkColumnResizeFlex
      }],
      standalone: true
    }]
  }], () => [{
    type: ColumnResizeNotifier
  }, {
    type: ElementRef
  }, {
    type: HeaderRowEventDispatcher
  }, {
    type: NgZone
  }, {
    type: ColumnResizeNotifierSource
  }, {
    type: CdkTable
  }], null);
})();
var CdkColumnResizeModule = class _CdkColumnResizeModule {
  static {
    this.ɵfac = function CdkColumnResizeModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CdkColumnResizeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _CdkColumnResizeModule,
      imports: [CdkColumnResize, CdkColumnResizeFlex],
      exports: [CdkColumnResize, CdkColumnResizeFlex]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnResizeModule, [{
    type: NgModule,
    args: [{
      imports: [CdkColumnResize, CdkColumnResizeFlex],
      exports: [CdkColumnResize, CdkColumnResizeFlex]
    }]
  }], null, null);
})();
var ColumnSizeStore = class _ColumnSizeStore {
  static {
    this.ɵfac = function ColumnSizeStore_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ColumnSizeStore)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ColumnSizeStore,
      factory: _ColumnSizeStore.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnSizeStore, [{
    type: Injectable
  }], null, null);
})();
var ResizeRef = class {
  constructor(origin, overlayRef, minWidthPx, maxWidthPx) {
    this.origin = origin;
    this.overlayRef = overlayRef;
    this.minWidthPx = minWidthPx;
    this.maxWidthPx = maxWidthPx;
  }
};
var OVERLAY_ACTIVE_CLASS = "cdk-resizable-overlay-thumb-active";
var Resizable = class _Resizable {
  constructor() {
    this.isResizable = true;
    this.minWidthPxInternal = 0;
    this.maxWidthPxInternal = Number.MAX_SAFE_INTEGER;
    this.destroyed = new Subject();
    this._viewInitialized = false;
    this._isDestroyed = false;
  }
  /** The minimum width to allow the column to be sized to. */
  get minWidthPx() {
    return this.minWidthPxInternal;
  }
  set minWidthPx(value) {
    if (value) {
      this.minWidthPxInternal = value;
    }
    this.columnResize.setResized();
    if (this.elementRef.nativeElement && this._viewInitialized) {
      this._applyMinWidthPx();
    }
  }
  /** The maximum width to allow the column to be sized to. */
  get maxWidthPx() {
    return this.maxWidthPxInternal;
  }
  set maxWidthPx(value) {
    if (value) {
      this.maxWidthPxInternal = value;
    }
    this.columnResize.setResized();
    if (this.elementRef.nativeElement && this._viewInitialized) {
      this._applyMaxWidthPx();
    }
  }
  ngAfterViewInit() {
    if (this.isResizable) {
      this._listenForRowHoverEvents();
      this._listenForResizeEvents();
      this._appendInlineHandle();
      this.styleScheduler.scheduleEnd(() => {
        if (this._isDestroyed) return;
        this._viewInitialized = true;
        this._applyMinWidthPx();
        this._applyMaxWidthPx();
      });
    }
  }
  ngOnDestroy() {
    this._isDestroyed = true;
    this.destroyed.next();
    this.destroyed.complete();
    this.inlineHandle?.remove();
    this.overlayRef?.dispose();
  }
  _createOverlayForHandle() {
    const isRtl = this.directionality.value === "rtl";
    const positionStrategy = this.overlay.position().flexibleConnectedTo(this.elementRef.nativeElement).withFlexibleDimensions(false).withGrowAfterOpen(false).withPush(false).withDefaultOffsetX(isRtl ? 1 : 0).withPositions([{
      originX: isRtl ? "start" : "end",
      originY: "top",
      overlayX: "center",
      overlayY: "top"
    }]);
    return this.overlay.create({
      // Always position the overlay based on left-indexed coordinates.
      direction: "ltr",
      disposeOnNavigation: true,
      positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition(),
      width: "16px"
    });
  }
  _listenForRowHoverEvents() {
    const element = this.elementRef.nativeElement;
    const takeUntilDestroyed = takeUntil(this.destroyed);
    this.eventDispatcher.resizeOverlayVisibleForHeaderRow(closest(element, HEADER_ROW_SELECTOR)).pipe(takeUntilDestroyed).subscribe((hoveringRow) => {
      if (hoveringRow) {
        if (!this.overlayRef) {
          this.overlayRef = this._createOverlayForHandle();
        }
        this._showHandleOverlay();
      } else if (this.overlayRef) {
        this.overlayRef.detach();
      }
    });
  }
  _listenForResizeEvents() {
    const takeUntilDestroyed = takeUntil(this.destroyed);
    merge(this.resizeNotifier.resizeCanceled, this.resizeNotifier.triggerResize).pipe(takeUntilDestroyed, filter((columnSize) => columnSize.columnId === this.columnDef.name)).subscribe(({
      size,
      previousSize,
      completeImmediately
    }) => {
      this.elementRef.nativeElement.classList.add(OVERLAY_ACTIVE_CLASS);
      this._applySize(size, previousSize);
      if (completeImmediately) {
        this._completeResizeOperation();
      }
    });
    merge(this.resizeNotifier.resizeCanceled, this.resizeNotifier.resizeCompleted).pipe(takeUntilDestroyed).subscribe((columnSize) => {
      this._cleanUpAfterResize(columnSize);
    });
  }
  _completeResizeOperation() {
    this.ngZone.run(() => {
      this.resizeNotifier.resizeCompleted.next({
        columnId: this.columnDef.name,
        size: this.elementRef.nativeElement.offsetWidth
      });
    });
  }
  _cleanUpAfterResize(columnSize) {
    this.elementRef.nativeElement.classList.remove(OVERLAY_ACTIVE_CLASS);
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this._updateOverlayHandleHeight();
      this.overlayRef.updatePosition();
      if (columnSize.columnId === this.columnDef.name) {
        this.inlineHandle.focus();
      }
    }
  }
  _createHandlePortal() {
    const injector = Injector.create({
      parent: this.injector,
      providers: [{
        provide: ResizeRef,
        useValue: new ResizeRef(this.elementRef, this.overlayRef, this.minWidthPx, this.maxWidthPx)
      }]
    });
    return new ComponentPortal(this.getOverlayHandleComponentType(), this.viewContainerRef, injector);
  }
  _showHandleOverlay() {
    this._updateOverlayHandleHeight();
    this.overlayRef.attach(this._createHandlePortal());
    this.changeDetectorRef.markForCheck();
  }
  _updateOverlayHandleHeight() {
    this.overlayRef.updateSize({
      height: this.elementRef.nativeElement.offsetHeight
    });
  }
  _applySize(sizeInPixels, previousSize) {
    const sizeToApply = Math.min(Math.max(sizeInPixels, this.minWidthPx, 0), this.maxWidthPx);
    this.resizeStrategy.applyColumnSize(this.columnDef.cssClassFriendlyName, this.elementRef.nativeElement, sizeToApply, previousSize);
  }
  _applyMinWidthPx() {
    this.resizeStrategy.applyMinColumnSize(this.columnDef.cssClassFriendlyName, this.elementRef.nativeElement, this.minWidthPx);
  }
  _applyMaxWidthPx() {
    this.resizeStrategy.applyMaxColumnSize(this.columnDef.cssClassFriendlyName, this.elementRef.nativeElement, this.maxWidthPx);
  }
  _appendInlineHandle() {
    this.styleScheduler.schedule(() => {
      this.inlineHandle = this.document.createElement("div");
      this.inlineHandle.tabIndex = 0;
      this.inlineHandle.className = this.getInlineHandleCssClassName();
      this.elementRef.nativeElement.appendChild(this.inlineHandle);
    });
  }
  static {
    this.ɵfac = function Resizable_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Resizable)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _Resizable
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Resizable, [{
    type: Directive
  }], null, null);
})();
var ResizeOverlayHandle = class _ResizeOverlayHandle {
  constructor() {
    this.destroyed = new Subject();
  }
  ngAfterViewInit() {
    this._listenForMouseEvents();
  }
  ngOnDestroy() {
    this.destroyed.next();
    this.destroyed.complete();
  }
  _listenForMouseEvents() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.elementRef.nativeElement, "mouseenter").pipe(mapTo(this.resizeRef.origin.nativeElement), takeUntil(this.destroyed)).subscribe((cell) => this.eventDispatcher.headerCellHovered.next(cell));
      fromEvent(this.elementRef.nativeElement, "mouseleave").pipe(map((event) => event.relatedTarget && closest(event.relatedTarget, HEADER_CELL_SELECTOR)), takeUntil(this.destroyed)).subscribe((cell) => this.eventDispatcher.headerCellHovered.next(cell));
      fromEvent(this.elementRef.nativeElement, "mousedown").pipe(takeUntil(this.destroyed)).subscribe((mousedownEvent) => {
        this._dragStarted(mousedownEvent);
      });
    });
  }
  _dragStarted(mousedownEvent) {
    if (mousedownEvent.button !== 0) {
      return;
    }
    const mouseup = fromEvent(this.document, "mouseup");
    const mousemove = fromEvent(this.document, "mousemove");
    const escape = fromEvent(this.document, "keyup").pipe(filter((event) => event.keyCode === ESCAPE));
    const startX = mousedownEvent.screenX;
    const initialSize = this._getOriginWidth();
    let overlayOffset = 0;
    let originOffset = this._getOriginOffset();
    let size = initialSize;
    let overshot = 0;
    this.updateResizeActive(true);
    mouseup.pipe(takeUntil(merge(escape, this.destroyed))).subscribe(({
      screenX
    }) => {
      this.styleScheduler.scheduleEnd(() => {
        this._notifyResizeEnded(size, screenX !== startX);
      });
    });
    escape.pipe(takeUntil(merge(mouseup, this.destroyed))).subscribe(() => {
      this._notifyResizeEnded(initialSize);
    });
    mousemove.pipe(map(({
      screenX
    }) => screenX), startWith(startX), distinctUntilChanged(), pairwise(), takeUntil(merge(mouseup, escape, this.destroyed))).subscribe(([prevX, currX]) => {
      let deltaX = currX - prevX;
      if (overshot !== 0) {
        if (overshot < 0 && deltaX < 0 || overshot > 0 && deltaX > 0) {
          overshot += deltaX;
          return;
        } else {
          const remainingOvershot = overshot + deltaX;
          overshot = overshot > 0 ? Math.max(remainingOvershot, 0) : Math.min(remainingOvershot, 0);
          deltaX = remainingOvershot - overshot;
          if (deltaX === 0) {
            return;
          }
        }
      }
      let computedNewSize = size + (this._isLtr() ? deltaX : -deltaX);
      computedNewSize = Math.min(Math.max(computedNewSize, this.resizeRef.minWidthPx, 0), this.resizeRef.maxWidthPx);
      this.resizeNotifier.triggerResize.next({
        columnId: this.columnDef.name,
        size: computedNewSize,
        previousSize: size,
        isStickyColumn: this.columnDef.sticky || this.columnDef.stickyEnd
      });
      this.styleScheduler.scheduleEnd(() => {
        const originNewSize = this._getOriginWidth();
        const originNewOffset = this._getOriginOffset();
        const originOffsetDeltaX = originNewOffset - originOffset;
        const originSizeDeltaX = originNewSize - size;
        size = originNewSize;
        originOffset = originNewOffset;
        overshot += deltaX + (this._isLtr() ? -originSizeDeltaX : originSizeDeltaX);
        overlayOffset += originOffsetDeltaX + (this._isLtr() ? originSizeDeltaX : 0);
        this._updateOverlayOffset(overlayOffset);
      });
    });
  }
  updateResizeActive(active) {
    this.eventDispatcher.overlayHandleActiveForCell.next(active ? this.resizeRef.origin.nativeElement : null);
  }
  _getOriginWidth() {
    return this.resizeRef.origin.nativeElement.offsetWidth;
  }
  _getOriginOffset() {
    return this.resizeRef.origin.nativeElement.offsetLeft;
  }
  _updateOverlayOffset(offset) {
    this.resizeRef.overlayRef.overlayElement.style.transform = `translateX(${coerceCssPixelValue(offset)})`;
  }
  _isLtr() {
    return this.directionality.value === "ltr";
  }
  _notifyResizeEnded(size, completedSuccessfully = false) {
    this.updateResizeActive(false);
    this.ngZone.run(() => {
      const sizeMessage = {
        columnId: this.columnDef.name,
        size
      };
      if (completedSuccessfully) {
        this.resizeNotifier.resizeCompleted.next(sizeMessage);
      } else {
        this.resizeNotifier.resizeCanceled.next(sizeMessage);
      }
    });
  }
  static {
    this.ɵfac = function ResizeOverlayHandle_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ResizeOverlayHandle)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _ResizeOverlayHandle
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeOverlayHandle, [{
    type: Directive
  }], null, null);
})();

// node_modules/@ng-matero/extensions/fesm2022/mtxGrid.mjs
var _c0 = ["top"];
var _c1 = (a0, a1, a2, a3, a4) => [a0, a1, a2, a3, a4];
function MtxGridCell_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 0);
    ɵɵpipe(1, "cellSummary");
    ɵɵpipe(2, "cellSummary");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("title", ctx_r0._getFormatterTooltip(ɵɵpipeBind2(1, 2, ctx_r0.data, ctx_r0.colDef)))("innerHTML", ctx_r0._getText(ɵɵpipeBind2(2, 5, ctx_r0.data, ctx_r0.colDef)), ɵɵsanitizeHtml);
  }
}
function MtxGridCell_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r0._getFormatterTooltip(ctx_r0.colDef.formatter(ctx_r0.rowData, ctx_r0.colDef)))("innerHTML", ctx_r0._getText(ctx_r0.colDef.formatter(ctx_r0.rowData, ctx_r0.colDef)), ɵɵsanitizeHtml);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_0_Conditional_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_0_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_0_Conditional_24_Template, 2, 1, "mat-icon", 12);
    ɵɵelementStart(25, "span");
    ɵɵtext(26);
    ɵɵpipe(27, "toObservable");
    ɵɵpipe(28, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 22, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 31, ɵɵpipeBind1(3, 29, ɵɵpipeBind1(2, 27, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 33, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 35, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 37, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 39, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 41, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 43, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 45, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 51, ɵɵpipeBind1(13, 49, ɵɵpipeBind1(12, 47, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 57, ɵɵpipeBind1(16, 55, ɵɵpipeBind1(15, 53, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 59, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 61, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 63, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 65, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 67, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 69, btn_r3).hidden);
    ɵɵadvance(24);
    ɵɵconditional(btn_r3.icon ? 24 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(28, 73, ɵɵpipeBind1(27, 71, btn_r3.text)));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_1_Conditional_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_1_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_1_Conditional_24_Template, 2, 1, "mat-icon", 12);
    ɵɵelementStart(25, "span");
    ɵɵtext(26);
    ɵɵpipe(27, "toObservable");
    ɵɵpipe(28, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 22, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 31, ɵɵpipeBind1(3, 29, ɵɵpipeBind1(2, 27, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 33, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 35, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 37, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 39, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 41, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 43, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 45, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 51, ɵɵpipeBind1(13, 49, ɵɵpipeBind1(12, 47, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 57, ɵɵpipeBind1(16, 55, ɵɵpipeBind1(15, 53, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 59, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 61, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 63, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 65, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 67, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 69, btn_r3).hidden);
    ɵɵadvance(24);
    ɵɵconditional(btn_r3.icon ? 24 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(28, 73, ɵɵpipeBind1(27, 71, btn_r3.text)));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_2_Conditional_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 14);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_2_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_2_Conditional_24_Template, 2, 1, "mat-icon", 12);
    ɵɵelementStart(25, "span");
    ɵɵtext(26);
    ɵɵpipe(27, "toObservable");
    ɵɵpipe(28, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 22, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 31, ɵɵpipeBind1(3, 29, ɵɵpipeBind1(2, 27, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 33, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 35, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 37, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 39, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 41, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 43, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 45, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 51, ɵɵpipeBind1(13, 49, ɵɵpipeBind1(12, 47, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 57, ɵɵpipeBind1(16, 55, ɵɵpipeBind1(15, 53, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 59, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 61, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 63, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 65, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 67, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 69, btn_r3).hidden);
    ɵɵadvance(24);
    ɵɵconditional(btn_r3.icon ? 24 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(28, 73, ɵɵpipeBind1(27, 71, btn_r3.text)));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 15);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_3_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵelementStart(24, "mat-icon", 12);
    ɵɵtext(25);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 21, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 30, ɵɵpipeBind1(3, 28, ɵɵpipeBind1(2, 26, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 32, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 34, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 36, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 38, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 40, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 42, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 44, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 50, ɵɵpipeBind1(13, 48, ɵɵpipeBind1(12, 46, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 56, ɵɵpipeBind1(16, 54, ɵɵpipeBind1(15, 52, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 58, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 60, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 62, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 64, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 66, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 68, btn_r3).hidden);
    ɵɵadvance(25);
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 16);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_4_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r7);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵelementStart(24, "mat-icon", 12);
    ɵɵtext(25);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 21, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 30, ɵɵpipeBind1(3, 28, ɵɵpipeBind1(2, 26, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 32, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 34, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 36, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 38, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 40, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 42, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 44, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 50, ɵɵpipeBind1(13, 48, ɵɵpipeBind1(12, 46, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 56, ɵɵpipeBind1(16, 54, ɵɵpipeBind1(15, 52, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 58, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 60, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 62, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 64, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 66, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 68, btn_r3).hidden);
    ɵɵadvance(25);
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 17);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_5_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r8);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵelementStart(24, "mat-icon", 12);
    ɵɵtext(25);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 21, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 30, ɵɵpipeBind1(3, 28, ɵɵpipeBind1(2, 26, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 32, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 34, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 36, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 38, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 40, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 42, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 44, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 50, ɵɵpipeBind1(13, 48, ɵɵpipeBind1(12, 46, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 56, ɵɵpipeBind1(16, 54, ɵɵpipeBind1(15, 52, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 58, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 60, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 62, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 64, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 66, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 68, btn_r3).hidden);
    ɵɵadvance(25);
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_6_Conditional_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(btn_r3.icon);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 18);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_6_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const btn_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r3, ctx_r0.rowData));
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_6_Conditional_24_Template, 2, 1, "mat-icon", 12);
    ɵɵelementStart(25, "span");
    ɵɵtext(26);
    ɵɵpipe(27, "toObservable");
    ɵɵpipe(28, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassMap(btn_r3.class);
    ɵɵproperty("color", btn_r3.color || "primary")("disabled", ɵɵpipeBind4(1, 22, btn_r3, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 31, ɵɵpipeBind1(3, 29, ɵɵpipeBind1(2, 27, btn_r3).message)))("matTooltipClass", ɵɵpipeBind1(5, 33, btn_r3).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 35, btn_r3).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 37, btn_r3).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 39, btn_r3).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 41, btn_r3).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 43, btn_r3).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 45, btn_r3).disabled)("matBadge", ɵɵpipeBind1(14, 51, ɵɵpipeBind1(13, 49, ɵɵpipeBind1(12, 47, btn_r3).content)))("matBadgeDescription", ɵɵpipeBind1(17, 57, ɵɵpipeBind1(16, 55, ɵɵpipeBind1(15, 53, btn_r3).description)))("matBadgeColor", ɵɵpipeBind1(18, 59, btn_r3).color)("matBadgePosition", ɵɵpipeBind1(19, 61, btn_r3).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 63, btn_r3).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 65, btn_r3).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 67, btn_r3).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 69, btn_r3).hidden);
    ɵɵadvance(24);
    ɵɵconditional(btn_r3.icon ? 24 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(28, 73, ɵɵpipeBind1(27, 71, btn_r3.text)));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_0_Template, 29, 75, "button", 4)(1, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_1_Template, 29, 75, "button", 5)(2, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_2_Template, 29, 75, "button", 6)(3, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_3_Template, 26, 70, "button", 7)(4, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_4_Template, 26, 70, "button", 8)(5, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_5_Template, 26, 70, "button", 9)(6, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Case_6_Template, 29, 75, "button", 10);
  }
  if (rf & 2) {
    let tmp_14_0;
    const btn_r3 = ɵɵnextContext().$implicit;
    ɵɵconditional((tmp_14_0 = btn_r3.type) === "raised" ? 0 : tmp_14_0 === "stroked" ? 1 : tmp_14_0 === "flat" ? 2 : tmp_14_0 === "icon" ? 3 : tmp_14_0 === "fab" ? 4 : tmp_14_0 === "mini-fab" ? 5 : 6);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Template, 7, 1);
  }
  if (rf & 2) {
    const btn_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵconditional(!btn_r3.iif || btn_r3.iif(ctx_r0.rowData) ? 0 : -1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵpipe(2, "cellActions");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵrepeater(ɵɵpipeBind4(2, 0, ctx_r0.colDef.buttons, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip-listbox")(1, "mat-chip", 19);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵclassMap("bg-" + ctx_r0.colDef.tag[ctx_r0._value].color);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.colDef.tag[ctx_r0._value].text, " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵtextInterpolate1(" ", ctx_r0._value, " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_0_Template, 3, 3, "mat-chip-listbox")(1, MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r0.colDef.tag && ctx_r0.colDef.tag[ctx_r0._value] ? 0 : 1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("href", ctx_r0._value, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._value);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("src", ctx_r0._value, ɵɵsanitizeUrl);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ctx_r0._value));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getText(ctx_r0._value));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵpipe(1, "number");
    ɵɵtext(2);
    ɵɵpipe(3, "number");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBind3(1, 2, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBind3(3, 6, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵpipe(1, "currency");
    ɵɵtext(2);
    ɵɵpipe(3, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBindV(1, 2, ɵɵpureFunction5(14, _c1, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.currencyCode, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.display, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale))));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBindV(3, 8, ɵɵpureFunction5(20, _c1, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.currencyCode, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.display, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale))), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵpipe(1, "percent");
    ɵɵtext(2);
    ɵɵpipe(3, "percent");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBind3(1, 2, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBind3(3, 6, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵpipe(1, "date");
    ɵɵtext(2);
    ɵɵpipe(3, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBind4(1, 2, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.format, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.timezone, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBind4(3, 7, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.format, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.timezone, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ctx_r0._value));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getText(ctx_r0._value));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_Template, 3, 5)(1, MtxGridCell_Conditional_1_Conditional_1_Case_1_Template, 2, 1)(2, MtxGridCell_Conditional_1_Conditional_1_Case_2_Template, 2, 2, "a", 1)(3, MtxGridCell_Conditional_1_Conditional_1_Case_3_Template, 1, 1, "img", 2)(4, MtxGridCell_Conditional_1_Conditional_1_Case_4_Template, 2, 2, "span", 3)(5, MtxGridCell_Conditional_1_Conditional_1_Case_5_Template, 4, 10, "span", 3)(6, MtxGridCell_Conditional_1_Conditional_1_Case_6_Template, 4, 26, "span", 3)(7, MtxGridCell_Conditional_1_Conditional_1_Case_7_Template, 4, 10, "span", 3)(8, MtxGridCell_Conditional_1_Conditional_1_Case_8_Template, 4, 12, "span", 3)(9, MtxGridCell_Conditional_1_Conditional_1_Case_9_Template, 2, 2, "span", 3);
  }
  if (rf & 2) {
    let tmp_2_0;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional((tmp_2_0 = ctx_r0.colDef.type) === "button" ? 0 : tmp_2_0 === "tag" ? 1 : tmp_2_0 === "link" ? 2 : tmp_2_0 === "image" ? 3 : tmp_2_0 === "boolean" ? 4 : tmp_2_0 === "number" ? 5 : tmp_2_0 === "currency" ? 6 : tmp_2_0 === "percent" ? 7 : tmp_2_0 === "date" ? 8 : 9);
  }
}
function MtxGridCell_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridCell_Conditional_1_Conditional_0_Template, 1, 2, "span", 0)(1, MtxGridCell_Conditional_1_Conditional_1_Template, 10, 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.colDef.formatter ? 0 : 1);
  }
}
var _c2 = ["menu"];
var _c3 = (a0) => ({
  $implicit: a0
});
function MtxGridColumnMenu_Case_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 17);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_0_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_Case_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 18);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_1_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_Case_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 19);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_2_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_Case_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 20);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_3_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
  }
}
function MtxGridColumnMenu_Case_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 21);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_4_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_Case_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 22);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_5_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_Case_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 23);
    ɵɵtemplate(1, MtxGridColumnMenu_Case_6_Conditional_1_Template, 2, 1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menu_r3 = ɵɵreference(8);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.buttonIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_Conditional_10_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_10_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridColumnMenu_Conditional_10_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.headerTemplate);
  }
}
function MtxGridColumnMenu_Conditional_10_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.headerText, " ");
  }
}
function MtxGridColumnMenu_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, MtxGridColumnMenu_Conditional_10_Conditional_1_Template, 1, 1, null, 24)(2, MtxGridColumnMenu_Conditional_10_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r1.headerTemplate ? 1 : 2);
  }
}
function MtxGridColumnMenu_Conditional_12_For_2_ng_template_3_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_12_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 27);
    ɵɵelement(2, "path", 28);
    ɵɵelementEnd();
    ɵɵtemplate(3, MtxGridColumnMenu_Conditional_12_For_2_ng_template_3_Template, 0, 0, "ng-template", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    const checkboxList_r6 = ɵɵreference(16);
    ɵɵproperty("cdkDragDisabled", ctx_r1.selectableChecked === "show" ? !col_r5.show : col_r5.hide);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", checkboxList_r6)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c3, col_r5));
  }
}
function MtxGridColumnMenu_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 25);
    ɵɵlistener("cdkDropListDropped", function MtxGridColumnMenu_Conditional_12_Template_div_cdkDropListDropped_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handleDroped($event));
    });
    ɵɵrepeaterCreate(1, MtxGridColumnMenu_Conditional_12_For_2_Template, 4, 5, "div", 26, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.columns);
  }
}
function MtxGridColumnMenu_Conditional_13_For_2_ng_template_1_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_13_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30);
    ɵɵtemplate(1, MtxGridColumnMenu_Conditional_13_For_2_ng_template_1_Template, 0, 0, "ng-template", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r7 = ctx.$implicit;
    ɵɵnextContext(2);
    const checkboxList_r6 = ɵɵreference(16);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", checkboxList_r6)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c3, col_r7));
  }
}
function MtxGridColumnMenu_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵrepeaterCreate(1, MtxGridColumnMenu_Conditional_13_For_2_Template, 2, 4, "div", 30, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.columns);
  }
}
function MtxGridColumnMenu_Conditional_14_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_14_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridColumnMenu_Conditional_14_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.footerTemplate);
  }
}
function MtxGridColumnMenu_Conditional_14_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.footerText, " ");
  }
}
function MtxGridColumnMenu_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵtemplate(1, MtxGridColumnMenu_Conditional_14_Conditional_1_Template, 1, 1, null, 24)(2, MtxGridColumnMenu_Conditional_14_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r1.footerTemplate ? 1 : 2);
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 34);
    ɵɵelement(1, "path", 38);
    ɵɵelementEnd();
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 35);
    ɵɵelement(1, "path", 39);
    ɵɵelementEnd();
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_0_For_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 42);
    ɵɵelement(1, "path", 44);
    ɵɵelementEnd();
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_0_For_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 40);
    ɵɵlistener("click", function MtxGridColumnMenu_ng_template_15_Conditional_0_For_6_Template_button_click_0_listener() {
      const item_r9 = ɵɵrestoreView(_r8).$implicit;
      const col_r10 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handlePinSelect(col_r10, item_r9.value));
    });
    ɵɵelementStart(1, "span", 41);
    ɵɵtemplate(2, MtxGridColumnMenu_ng_template_15_Conditional_0_For_6_Conditional_2_Template, 2, 0, ":svg:svg", 42);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 43);
    ɵɵtext(4);
    ɵɵpipe(5, "toObservable");
    ɵɵpipe(6, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const col_r10 = ɵɵnextContext(2).$implicit;
    ɵɵadvance(2);
    ɵɵconditional(col_r10.pinned == item_r9.value ? 2 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(6, 4, ɵɵpipeBind1(5, 2, item_r9.label)));
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 33);
    ɵɵtemplate(1, MtxGridColumnMenu_ng_template_15_Conditional_0_Conditional_1_Template, 2, 0, ":svg:svg", 34)(2, MtxGridColumnMenu_ng_template_15_Conditional_0_Conditional_2_Template, 2, 0, ":svg:svg", 35);
    ɵɵelementEnd();
    ɵɵelementStart(3, "mat-menu", 36, 2);
    ɵɵrepeaterCreate(5, MtxGridColumnMenu_ng_template_15_Conditional_0_For_6_Template, 7, 6, "button", 37, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const pinList_r11 = ɵɵreference(4);
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matMenuTriggerFor", pinList_r11);
    ɵɵadvance();
    ɵɵconditional(col_r10.pinned ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!col_r10.pinned ? 2 : -1);
    ɵɵadvance(3);
    ɵɵrepeater(ctx_r1.pinOptions);
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 45);
    ɵɵtwoWayListener("ngModelChange", function MtxGridColumnMenu_ng_template_15_Conditional_1_Template_mat_checkbox_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r12);
      const col_r10 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(col_r10[ctx_r1.selectableChecked], $event) || (col_r10[ctx_r1.selectableChecked] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("change", function MtxGridColumnMenu_ng_template_15_Conditional_1_Template_mat_checkbox_change_0_listener() {
      ɵɵrestoreView(_r12);
      const col_r10 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handleChecked(col_r10));
    });
    ɵɵtext(1);
    ɵɵpipe(2, "toObservable");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵtwoWayProperty("ngModel", col_r10[ctx_r1.selectableChecked]);
    ɵɵproperty("disabled", col_r10.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(3, 5, ɵɵpipeBind1(2, 3, col_r10.header)));
  }
}
function MtxGridColumnMenu_ng_template_15_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 32);
    ɵɵtext(1);
    ɵɵpipe(2, "toObservable");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(3, 3, ɵɵpipeBind1(2, 1, col_r10.header)));
  }
}
function MtxGridColumnMenu_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridColumnMenu_ng_template_15_Conditional_0_Template, 7, 3)(1, MtxGridColumnMenu_ng_template_15_Conditional_1_Template, 4, 7, "mat-checkbox", 31)(2, MtxGridColumnMenu_ng_template_15_Conditional_2_Template, 4, 5, "span", 32);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.pinnable ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.selectable ? 1 : 2);
  }
}
var _c4 = ["columnMenu"];
var _c5 = ["tableContainer"];
var _c6 = (a0, a1, a2) => ({
  "mat-table-hover": a0,
  "mat-table-striped": a1,
  "mat-table-expandable": a2
});
var _c7 = (a0, a1, a2, a3) => ({
  "width": a0,
  "min-width": a1,
  "left": a2,
  "right": a3
});
var _c8 = (a0, a1) => ({
  $implicit: a0,
  colDef: a1
});
var _c9 = (a0, a1, a2, a3) => ({
  $implicit: a0,
  rowData: a1,
  index: a2,
  colDef: a3
});
var _c10 = (a0, a1, a2) => ({
  $implicit: a0,
  colDef: a1,
  data: a2
});
var _c11 = (a0, a1, a2) => ({
  $implicit: a0,
  colData: a1,
  colDef: a2
});
var _c12 = () => ["MtxGridExpansionColumnDef"];
var _c13 = (a0, a1, a2, a3) => ({
  $implicit: a0,
  rowData: a1,
  index: a2,
  expanded: a3
});
var _c14 = (a0, a1, a2) => ({
  "width": a0,
  "left": a1,
  "right": a2
});
function MtxGrid_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "mat-progress-bar", 17);
    ɵɵelementEnd();
  }
}
function MtxGrid_Conditional_1_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_1_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplate);
  }
}
function MtxGrid_Conditional_1_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.toolbarTitle);
  }
}
function MtxGrid_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_1_Conditional_3_Conditional_0_Template, 2, 1, "div", 21);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r0.toolbarTitle ? 0 : -1);
  }
}
function MtxGrid_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mtx-grid-column-menu", 22, 2);
    ɵɵlistener("columnChange", function MtxGrid_Conditional_1_Conditional_5_Template_mtx_grid_column_menu_columnChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onColumnChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("columns", ctx_r0.columns)("buttonText", ctx_r0.columnMenuButtonText)("buttonType", ctx_r0.columnMenuButtonType)("buttonColor", ctx_r0.columnMenuButtonColor)("buttonClass", ctx_r0.columnMenuButtonClass)("buttonIcon", ctx_r0.columnMenuButtonIcon)("selectable", ctx_r0.columnHideable)("selectableChecked", ctx_r0.columnHideableChecked)("sortable", ctx_r0.columnSortable)("pinnable", ctx_r0.columnPinnable)("showHeader", ctx_r0.showColumnMenuHeader)("headerText", ctx_r0.columnMenuHeaderText)("headerTemplate", ctx_r0.columnMenuHeaderTemplate)("showFooter", ctx_r0.showColumnMenuFooter)("footerText", ctx_r0.columnMenuFooterText)("footerTemplate", ctx_r0.columnMenuFooterTemplate)("pinOptions", ctx_r0.columnPinOptions);
  }
}
function MtxGrid_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4)(1, "div", 18);
    ɵɵtemplate(2, MtxGrid_Conditional_1_Conditional_2_Template, 1, 1, null, 15)(3, MtxGrid_Conditional_1_Conditional_3_Template, 1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 19);
    ɵɵtemplate(5, MtxGrid_Conditional_1_Conditional_5_Template, 2, 17, "mtx-grid-column-menu", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(ctx_r0.toolbarTemplate ? 2 : 3);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r0.showColumnMenuButton ? 5 : -1);
  }
}
function MtxGrid_Conditional_6_Conditional_1_th_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 34);
    ɵɵlistener("change", function MtxGrid_Conditional_6_Conditional_1_th_1_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView($event ? ctx_r0._toggleMasterCheckbox() : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("checked", ctx_r0.rowSelection.hasValue() && ctx_r0._isAllSelected())("indeterminate", ctx_r0.rowSelection.hasValue() && !ctx_r0._isAllSelected());
  }
}
function MtxGrid_Conditional_6_Conditional_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 32);
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_1_th_1_Conditional_1_Template, 1, 2, "mat-checkbox", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.multiSelectable ? 1 : -1);
  }
}
function MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 37);
    ɵɵlistener("click", function MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      return ɵɵresetView($event.stopPropagation());
    })("change", function MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r5);
      const row_r6 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView($event ? ctx_r0._toggleNormalCheckbox(row_r6) : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    const row_r6 = ctx_r6.$implicit;
    const index_r8 = ctx_r6.index;
    const dataIndex_r9 = ctx_r6.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("disabled", ctx_r0.rowSelectionFormatter.disabled && ctx_r0.rowSelectionFormatter.disabled(row_r6, ctx_r0._getIndex(index_r8, dataIndex_r9)))("checked", ctx_r0.rowSelection.isSelected(row_r6));
  }
}
function MtxGrid_Conditional_6_Conditional_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 35);
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template, 1, 2, "mat-checkbox", 36);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r6 = ctx.$implicit;
    const index_r8 = ctx.index;
    const dataIndex_r9 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(!(ctx_r0.rowSelectionFormatter.hideCheckbox && ctx_r0.rowSelectionFormatter.hideCheckbox(row_r6, ctx_r0._getIndex(index_r8, dataIndex_r9))) ? 1 : -1);
  }
}
function MtxGrid_Conditional_6_Conditional_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 38);
  }
}
function MtxGrid_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 24);
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_1_th_1_Template, 2, 1, "th", 29)(2, MtxGrid_Conditional_6_Conditional_1_td_2_Template, 2, 1, "td", 30)(3, MtxGrid_Conditional_6_Conditional_1_td_3_Template, 1, 0, "td", 31);
    ɵɵelementContainerEnd();
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_th_1_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c8, col_r10, col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate[col_r10.field])("ngTemplateOutletContext", ɵɵpureFunction2(2, _c8, col_r10, col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 46);
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 47);
    ɵɵelement(1, "path", 48);
    ɵɵelementEnd();
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45);
    ɵɵtemplate(1, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template, 1, 0, "span", 46);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵpipe(4, "toObservable");
    ɵɵpipe(5, "async");
    ɵɵelementEnd();
    ɵɵtemplate(6, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template, 2, 0, ":svg:svg", 47);
    ɵɵelementEnd();
    ɵɵtemplate(7, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    let tmp_18_0;
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    const headerExtraTplBase_r11 = ɵɵreference(16);
    ɵɵproperty("mat-sort-header", (col_r10.sortProp == null ? null : col_r10.sortProp.id) || col_r10.field)("disabled", !col_r10.sortable)("disableClear", (tmp_18_0 = col_r10.sortProp == null ? null : col_r10.sortProp.disableClear) !== null && tmp_18_0 !== void 0 ? tmp_18_0 : ctx_r0.sortDisableClear)("arrowPosition", col_r10.sortProp == null ? null : col_r10.sortProp.arrowPosition)("start", col_r10.sortProp == null ? null : col_r10.sortProp.start);
    ɵɵadvance();
    ɵɵconditional(col_r10.showExpand ? 1 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(5, 12, ɵɵpipeBind1(4, 10, col_r10.header)));
    ɵɵadvance(3);
    ɵɵconditional(col_r10.sortable ? 6 : -1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", headerExtraTplBase_r11)("ngTemplateOutletContext", ɵɵpureFunction2(14, _c8, ctx_r0.headerExtraTemplate, col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_Template, 1, 5, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Template, 8, 17);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.headerTemplate == null ? null : ctx_r0.headerTemplate[col_r10.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 42);
    ɵɵpipe(1, "colClass");
    ɵɵelementStart(2, "div", 43);
    ɵɵtemplate(3, MtxGrid_Conditional_6_For_3_th_1_Conditional_3_Template, 1, 5, null, 44);
    ɵɵpipe(4, "isTemplateRef");
    ɵɵtemplate(5, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Template, 3, 3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleMap(ɵɵpureFunction4(13, _c7, col_r10.width, col_r10.width, col_r10.left, col_r10.right));
    ɵɵclassMap(ɵɵpipeBind1(1, 9, col_r10));
    ɵɵclassProp("mat-table-sticky-left", col_r10.pinned === "left")("mat-table-sticky-right", col_r10.pinned === "right");
    ɵɵadvance(3);
    ɵɵconditional(ɵɵpipeBind1(4, 11, ctx_r0.headerTemplate) ? 3 : 5);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext();
    const row_r13 = ctx_r13.$implicit;
    const index_r15 = ctx_r13.index;
    const dataIndex_r16 = ctx_r13.dataIndex;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c9, row_r13, row_r13, ctx_r0._getIndex(index_r15, dataIndex_r16), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(2);
    const row_r13 = ctx_r13.$implicit;
    const index_r15 = ctx_r13.index;
    const dataIndex_r16 = ctx_r13.dataIndex;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate[col_r10.field])("ngTemplateOutletContext", ɵɵpureFunction4(2, _c9, row_r13, row_r13, ctx_r0._getIndex(index_r15, dataIndex_r16), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(3);
    const row_r13 = ctx_r13.$implicit;
    const index_r15 = ctx_r13.index;
    const dataIndex_r16 = ctx_r13.dataIndex;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r10.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c9, row_r13, row_r13, ctx_r0._getIndex(index_r15, dataIndex_r16), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 53);
    ɵɵtwoWayListener("openedChange", function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_openedChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const dataIndex_r16 = ɵɵnextContext(4).dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      ɵɵtwoWayBindingSet(ctx_r0.expansionRowStates[dataIndex_r16].expanded, $event) || (ctx_r0.expansionRowStates[dataIndex_r16].expanded = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("toggleChange", function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_toggleChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r13 = ɵɵnextContext(4);
      const row_r13 = ctx_r13.$implicit;
      const dataIndex_r16 = ctx_r13.dataIndex;
      const col_r10 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onExpansionChange($event, row_r13, col_r10, dataIndex_r16));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 54);
    ɵɵelement(2, "path", 55);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dataIndex_r16 = ɵɵnextContext(4).dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵtwoWayProperty("opened", ctx_r0.expansionRowStates[dataIndex_r16].expanded);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template, 3, 1, "button", 51);
    ɵɵelementStart(1, "mtx-grid-cell", 52);
    ɵɵlistener("rowDataChange", function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template_mtx_grid_cell_rowDataChange_1_listener($event) {
      ɵɵrestoreView(_r17);
      const ctx_r0 = ɵɵnextContext(6);
      return ɵɵresetView(ctx_r0._onRowDataChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r13 = ɵɵnextContext(3).$implicit;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(col_r10.showExpand ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("rowData", row_r13)("colDef", col_r10)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template, 1, 7, null, 44)(1, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template, 2, 4, "mtx-grid-cell", 50);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    ɵɵconditional(col_r10.cellTemplate ? 0 : 1);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_Template, 1, 7, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Template, 2, 1);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.cellTemplate == null ? null : ctx_r0.cellTemplate[col_r10.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 49);
    ɵɵpipe(1, "colClass");
    ɵɵlistener("cellSelectedChange", function MtxGrid_Conditional_6_For_3_td_2_Template_td_cellSelectedChange_0_listener($event) {
      const row_r13 = ɵɵrestoreView(_r12).$implicit;
      const col_r10 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._selectCell($event, row_r13, col_r10));
    });
    ɵɵtemplate(2, MtxGrid_Conditional_6_For_3_td_2_Conditional_2_Template, 1, 7, null, 44);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵtemplate(4, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r13 = ctx.$implicit;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleMap(ɵɵpureFunction4(17, _c7, col_r10.width, col_r10.width, col_r10.left, col_r10.right));
    ɵɵclassMap(ɵɵpipeBind4(1, 10, col_r10, row_r13, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue));
    ɵɵclassProp("mat-table-sticky-left", col_r10.pinned === "left")("mat-table-sticky-right", col_r10.pinned === "right");
    ɵɵproperty("cellSelectable", ctx_r0.cellSelectable);
    ɵɵadvance(2);
    ɵɵconditional(ɵɵpipeBind1(3, 15, ctx_r0.cellTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 46);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_3_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c10, col_r10, col_r10, ctx_r0.data));
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate[col_r10.field])("ngTemplateOutletContext", ɵɵpureFunction3(2, _c11, ctx_r0._getColData(ctx_r0.data, col_r10), ctx_r0._getColData(ctx_r0.data, col_r10), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mtx-grid-cell", 57);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("summary", true)("data", ctx_r0.data)("colDef", col_r10)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_Template, 1, 6, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_2_Template, 1, 4, "mtx-grid-cell", 57);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.summaryTemplate == null ? null : ctx_r0.summaryTemplate[col_r10.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 56);
    ɵɵtemplate(1, MtxGrid_Conditional_6_For_3_td_3_Conditional_1_Template, 1, 0, "span", 46)(2, MtxGrid_Conditional_6_For_3_td_3_Conditional_2_Template, 1, 6, null, 44);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵtemplate(4, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleMap(ɵɵpureFunction4(10, _c7, col_r10.width, col_r10.width, col_r10.left, col_r10.right));
    ɵɵclassProp("mat-table-sticky-left", col_r10.pinned === "left")("mat-table-sticky-right", col_r10.pinned === "right");
    ɵɵadvance();
    ɵɵconditional(col_r10.showExpand ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ɵɵpipeBind1(3, 8, ctx_r0.summaryTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_6_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 25);
    ɵɵtemplate(1, MtxGrid_Conditional_6_For_3_th_1_Template, 6, 18, "th", 39)(2, MtxGrid_Conditional_6_For_3_td_2_Template, 5, 22, "td", 40)(3, MtxGrid_Conditional_6_For_3_td_3_Template, 5, 15, "td", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const col_r10 = ctx.$implicit;
    ɵɵproperty("matColumnDef", col_r10.field)("sticky", col_r10.pinned === "left")("stickyEnd", col_r10.pinned === "right");
  }
}
function MtxGrid_Conditional_6_Conditional_4_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 26);
  }
}
function MtxGrid_Conditional_6_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_Conditional_4_tr_0_Template, 1, 0, "tr", 58);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matHeaderRowDef", ctx_r0.displayedColumns)("matHeaderRowDefSticky", true);
  }
}
function MtxGrid_Conditional_6_Conditional_5_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 60);
    ɵɵpipe(1, "rowClass");
    ɵɵlistener("click", function MtxGrid_Conditional_6_Conditional_5_tr_0_Template_tr_click_0_listener($event) {
      const ctx_r19 = ɵɵrestoreView(_r19);
      const row_r21 = ctx_r19.$implicit;
      const index_r22 = ctx_r19.index;
      const dataIndex_r23 = ctx_r19.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._selectRow($event, row_r21, ctx_r0._getIndex(index_r22, dataIndex_r23)));
    })("contextmenu", function MtxGrid_Conditional_6_Conditional_5_tr_0_Template_tr_contextmenu_0_listener($event) {
      const ctx_r23 = ɵɵrestoreView(_r19);
      const row_r21 = ctx_r23.$implicit;
      const index_r22 = ctx_r23.index;
      const dataIndex_r23 = ctx_r23.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._contextmenu($event, row_r21, ctx_r0._getIndex(index_r22, dataIndex_r23)));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r21 = ctx.$implicit;
    const index_r22 = ctx.index;
    const dataIndex_r23 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ɵɵpipeBind4(1, 4, row_r21, index_r22, dataIndex_r23, ctx_r0.rowClassFormatter));
    ɵɵclassProp("selected", ctx_r0.rowSelection.isSelected(row_r21));
  }
}
function MtxGrid_Conditional_6_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_Conditional_5_tr_0_Template, 2, 9, "tr", 59);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matRowDefColumns", ctx_r0.displayedColumns);
  }
}
function MtxGrid_Conditional_6_Conditional_6_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 28);
  }
}
function MtxGrid_Conditional_6_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_Conditional_6_tr_0_Template, 1, 0, "tr", 61);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matFooterRowDef", ctx_r0.displayedColumns)("matFooterRowDefSticky", true);
  }
}
function MtxGrid_Conditional_6_Conditional_7_td_1_ng_template_2_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_Conditional_7_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 65)(1, "div", 66);
    ɵɵtemplate(2, MtxGrid_Conditional_6_Conditional_7_td_1_ng_template_2_Template, 0, 0, "ng-template", 44);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r25 = ctx.$implicit;
    const dataIndex_r26 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵattribute("colspan", ctx_r0.displayedColumns.length);
    ɵɵadvance();
    ɵɵproperty("@expansion", ctx_r0.expansionRowStates[dataIndex_r26].expanded ? "expanded" : "collapsed");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.expansionTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(4, _c13, row_r25, row_r25, dataIndex_r26, ctx_r0.expansionRowStates[dataIndex_r26].expanded));
  }
}
function MtxGrid_Conditional_6_Conditional_7_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 67);
  }
  if (rf & 2) {
    const dataIndex_r27 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ctx_r0.expansionRowStates[dataIndex_r27].expanded ? "expanded" : "collapsed");
  }
}
function MtxGrid_Conditional_6_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 62);
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_7_td_1_Template, 3, 9, "td", 63);
    ɵɵelementContainerEnd();
    ɵɵtemplate(2, MtxGrid_Conditional_6_Conditional_7_tr_2_Template, 1, 2, "tr", 64);
  }
  if (rf & 2) {
    ɵɵadvance(2);
    ɵɵproperty("matRowDefColumns", ɵɵpureFunction0(1, _c12));
  }
}
function MtxGrid_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 23);
    ɵɵlistener("matSortChange", function MtxGrid_Conditional_6_Template_table_matSortChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onSortChange($event));
    });
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_1_Template, 4, 0, "ng-container", 24);
    ɵɵrepeaterCreate(2, MtxGrid_Conditional_6_For_3_Template, 4, 3, "ng-container", 25, ɵɵrepeaterTrackByIdentity);
    ɵɵtemplate(4, MtxGrid_Conditional_6_Conditional_4_Template, 1, 2, "tr", 26)(5, MtxGrid_Conditional_6_Conditional_5_Template, 1, 1, "tr", 27)(6, MtxGrid_Conditional_6_Conditional_6_Template, 1, 2, "tr", 28)(7, MtxGrid_Conditional_6_Conditional_7_Template, 3, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ɵɵpureFunction3(15, _c6, ctx_r0.rowHover, ctx_r0.rowStriped, ctx_r0.expandable));
    ɵɵproperty("dataSource", ctx_r0.dataSource)("multiTemplateDataRows", ctx_r0.expandable)("matSortActive", ctx_r0.sortActive)("matSortDirection", ctx_r0.sortDirection)("matSortDisableClear", ctx_r0.sortDisableClear)("matSortDisabled", ctx_r0.sortDisabled)("matSortStart", ctx_r0.sortStart)("trackBy", ctx_r0.trackBy);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.rowSelectable && !ctx_r0.hideRowSelectionCheckbox ? 1 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.columns);
    ɵɵadvance(2);
    ɵɵconditional(!ctx_r0.useContentHeaderRowTemplate ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.useContentRowTemplate ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0._whetherShowSummary ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.expandable ? 7 : -1);
  }
}
function MtxGrid_Conditional_7_Conditional_1_th_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 34);
    ɵɵlistener("change", function MtxGrid_Conditional_7_Conditional_1_th_1_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r29);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView($event ? ctx_r0._toggleMasterCheckbox() : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("checked", ctx_r0.rowSelection.hasValue() && ctx_r0._isAllSelected())("indeterminate", ctx_r0.rowSelection.hasValue() && !ctx_r0._isAllSelected());
  }
}
function MtxGrid_Conditional_7_Conditional_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 32);
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_1_th_1_Conditional_1_Template, 1, 2, "mat-checkbox", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.multiSelectable ? 1 : -1);
  }
}
function MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 37);
    ɵɵlistener("click", function MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_click_0_listener($event) {
      ɵɵrestoreView(_r30);
      return ɵɵresetView($event.stopPropagation());
    })("change", function MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r30);
      const row_r31 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView($event ? ctx_r0._toggleNormalCheckbox(row_r31) : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r31 = ɵɵnextContext();
    const row_r31 = ctx_r31.$implicit;
    const index_r33 = ctx_r31.index;
    const dataIndex_r34 = ctx_r31.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("disabled", ctx_r0.rowSelectionFormatter.disabled && ctx_r0.rowSelectionFormatter.disabled(row_r31, ctx_r0._getIndex(index_r33, dataIndex_r34)))("checked", ctx_r0.rowSelection.isSelected(row_r31));
  }
}
function MtxGrid_Conditional_7_Conditional_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 35);
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template, 1, 2, "mat-checkbox", 36);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r31 = ctx.$implicit;
    const index_r33 = ctx.index;
    const dataIndex_r34 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(!(ctx_r0.rowSelectionFormatter.hideCheckbox && ctx_r0.rowSelectionFormatter.hideCheckbox(row_r31, ctx_r0._getIndex(index_r33, dataIndex_r34))) ? 1 : -1);
  }
}
function MtxGrid_Conditional_7_Conditional_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 38);
  }
}
function MtxGrid_Conditional_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 24);
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_1_th_1_Template, 2, 1, "th", 29)(2, MtxGrid_Conditional_7_Conditional_1_td_2_Template, 2, 1, "td", 30)(3, MtxGrid_Conditional_7_Conditional_1_td_3_Template, 1, 0, "td", 31);
    ɵɵelementContainerEnd();
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_th_1_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c8, col_r35, col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate[col_r35.field])("ngTemplateOutletContext", ɵɵpureFunction2(2, _c8, col_r35, col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 46);
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 47);
    ɵɵelement(1, "path", 48);
    ɵɵelementEnd();
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45);
    ɵɵtemplate(1, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template, 1, 0, "span", 46);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵpipe(4, "toObservable");
    ɵɵpipe(5, "async");
    ɵɵelementEnd();
    ɵɵtemplate(6, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template, 2, 0, ":svg:svg", 47);
    ɵɵelementEnd();
    ɵɵtemplate(7, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    let tmp_18_0;
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    const headerExtraTplBase_r11 = ɵɵreference(16);
    ɵɵproperty("mat-sort-header", (col_r35.sortProp == null ? null : col_r35.sortProp.id) || col_r35.field)("disabled", !col_r35.sortable)("disableClear", (tmp_18_0 = col_r35.sortProp == null ? null : col_r35.sortProp.disableClear) !== null && tmp_18_0 !== void 0 ? tmp_18_0 : ctx_r0.sortDisableClear)("arrowPosition", col_r35.sortProp == null ? null : col_r35.sortProp.arrowPosition)("start", col_r35.sortProp == null ? null : col_r35.sortProp.start);
    ɵɵadvance();
    ɵɵconditional(col_r35.showExpand ? 1 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(5, 12, ɵɵpipeBind1(4, 10, col_r35.header)));
    ɵɵadvance(3);
    ɵɵconditional(col_r35.sortable ? 6 : -1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", headerExtraTplBase_r11)("ngTemplateOutletContext", ɵɵpureFunction2(14, _c8, ctx_r0.headerExtraTemplate, col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_Template, 1, 5, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Template, 8, 17);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.headerTemplate == null ? null : ctx_r0.headerTemplate[col_r35.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 70);
    ɵɵpipe(1, "colClass");
    ɵɵelementStart(2, "div", 43);
    ɵɵtemplate(3, MtxGrid_Conditional_7_For_3_th_1_Conditional_3_Template, 1, 5, null, 44);
    ɵɵpipe(4, "isTemplateRef");
    ɵɵtemplate(5, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Template, 3, 3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleMap(ɵɵpureFunction3(16, _c14, col_r35.width, col_r35.left, col_r35.right));
    ɵɵclassMap(ɵɵpipeBind1(1, 12, col_r35));
    ɵɵclassProp("mat-table-sticky-left", col_r35.pinned === "left")("mat-table-sticky-right", col_r35.pinned === "right");
    ɵɵproperty("resizable", col_r35.resizable)("matResizableMinWidthPx", col_r35.minWidth)("matResizableMaxWidthPx", col_r35.maxWidth);
    ɵɵadvance(3);
    ɵɵconditional(ɵɵpipeBind1(4, 14, ctx_r0.headerTemplate) ? 3 : 5);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r37 = ɵɵnextContext();
    const row_r37 = ctx_r37.$implicit;
    const index_r39 = ctx_r37.index;
    const dataIndex_r40 = ctx_r37.dataIndex;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c9, row_r37, row_r37, ctx_r0._getIndex(index_r39, dataIndex_r40), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r37 = ɵɵnextContext(2);
    const row_r37 = ctx_r37.$implicit;
    const index_r39 = ctx_r37.index;
    const dataIndex_r40 = ctx_r37.dataIndex;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate[col_r35.field])("ngTemplateOutletContext", ɵɵpureFunction4(2, _c9, row_r37, row_r37, ctx_r0._getIndex(index_r39, dataIndex_r40), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r37 = ɵɵnextContext(3);
    const row_r37 = ctx_r37.$implicit;
    const index_r39 = ctx_r37.index;
    const dataIndex_r40 = ctx_r37.dataIndex;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r35.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c9, row_r37, row_r37, ctx_r0._getIndex(index_r39, dataIndex_r40), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r42 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 53);
    ɵɵtwoWayListener("openedChange", function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_openedChange_0_listener($event) {
      ɵɵrestoreView(_r42);
      const dataIndex_r40 = ɵɵnextContext(4).dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      ɵɵtwoWayBindingSet(ctx_r0.expansionRowStates[dataIndex_r40].expanded, $event) || (ctx_r0.expansionRowStates[dataIndex_r40].expanded = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("toggleChange", function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_toggleChange_0_listener($event) {
      ɵɵrestoreView(_r42);
      const ctx_r37 = ɵɵnextContext(4);
      const row_r37 = ctx_r37.$implicit;
      const dataIndex_r40 = ctx_r37.dataIndex;
      const col_r35 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onExpansionChange($event, row_r37, col_r35, dataIndex_r40));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 54);
    ɵɵelement(2, "path", 55);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dataIndex_r40 = ɵɵnextContext(4).dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵtwoWayProperty("opened", ctx_r0.expansionRowStates[dataIndex_r40].expanded);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r41 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template, 3, 1, "button", 51);
    ɵɵelementStart(1, "mtx-grid-cell", 52);
    ɵɵlistener("rowDataChange", function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template_mtx_grid_cell_rowDataChange_1_listener($event) {
      ɵɵrestoreView(_r41);
      const ctx_r0 = ɵɵnextContext(6);
      return ɵɵresetView(ctx_r0._onRowDataChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r37 = ɵɵnextContext(3).$implicit;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(col_r35.showExpand ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("rowData", row_r37)("colDef", col_r35)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template, 1, 7, null, 44)(1, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template, 2, 4, "mtx-grid-cell", 50);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    ɵɵconditional(col_r35.cellTemplate ? 0 : 1);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_Template, 1, 7, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Template, 2, 1);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.cellTemplate == null ? null : ctx_r0.cellTemplate[col_r35.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r36 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 49);
    ɵɵpipe(1, "colClass");
    ɵɵlistener("cellSelectedChange", function MtxGrid_Conditional_7_For_3_td_2_Template_td_cellSelectedChange_0_listener($event) {
      const row_r37 = ɵɵrestoreView(_r36).$implicit;
      const col_r35 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._selectCell($event, row_r37, col_r35));
    });
    ɵɵtemplate(2, MtxGrid_Conditional_7_For_3_td_2_Conditional_2_Template, 1, 7, null, 44);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵtemplate(4, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r37 = ctx.$implicit;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleMap(ɵɵpureFunction3(17, _c14, col_r35.width, col_r35.left, col_r35.right));
    ɵɵclassMap(ɵɵpipeBind4(1, 10, col_r35, row_r37, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue));
    ɵɵclassProp("mat-table-sticky-left", col_r35.pinned === "left")("mat-table-sticky-right", col_r35.pinned === "right");
    ɵɵproperty("cellSelectable", ctx_r0.cellSelectable);
    ɵɵadvance(2);
    ɵɵconditional(ɵɵpipeBind1(3, 15, ctx_r0.cellTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 46);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_3_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c10, col_r35, col_r35, ctx_r0.data));
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate[col_r35.field])("ngTemplateOutletContext", ɵɵpureFunction3(2, _c11, ctx_r0._getColData(ctx_r0.data, col_r35), ctx_r0._getColData(ctx_r0.data, col_r35), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mtx-grid-cell", 57);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("summary", true)("data", ctx_r0.data)("colDef", col_r35)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_Template, 1, 6, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_2_Template, 1, 4, "mtx-grid-cell", 57);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.summaryTemplate == null ? null : ctx_r0.summaryTemplate[col_r35.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 56);
    ɵɵtemplate(1, MtxGrid_Conditional_7_For_3_td_3_Conditional_1_Template, 1, 0, "span", 46)(2, MtxGrid_Conditional_7_For_3_td_3_Conditional_2_Template, 1, 6, null, 44);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵtemplate(4, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleMap(ɵɵpureFunction3(10, _c14, col_r35.width, col_r35.left, col_r35.right));
    ɵɵclassProp("mat-table-sticky-left", col_r35.pinned === "left")("mat-table-sticky-right", col_r35.pinned === "right");
    ɵɵadvance();
    ɵɵconditional(col_r35.showExpand ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ɵɵpipeBind1(3, 8, ctx_r0.summaryTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_7_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 25);
    ɵɵtemplate(1, MtxGrid_Conditional_7_For_3_th_1_Template, 6, 20, "th", 69)(2, MtxGrid_Conditional_7_For_3_td_2_Template, 5, 21, "td", 40)(3, MtxGrid_Conditional_7_For_3_td_3_Template, 5, 14, "td", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const col_r35 = ctx.$implicit;
    ɵɵproperty("matColumnDef", col_r35.field)("sticky", col_r35.pinned === "left")("stickyEnd", col_r35.pinned === "right");
  }
}
function MtxGrid_Conditional_7_Conditional_4_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 26);
  }
}
function MtxGrid_Conditional_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_Conditional_4_tr_0_Template, 1, 0, "tr", 58);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matHeaderRowDef", ctx_r0.displayedColumns)("matHeaderRowDefSticky", true);
  }
}
function MtxGrid_Conditional_7_Conditional_5_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r43 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 60);
    ɵɵpipe(1, "rowClass");
    ɵɵlistener("click", function MtxGrid_Conditional_7_Conditional_5_tr_0_Template_tr_click_0_listener($event) {
      const ctx_r43 = ɵɵrestoreView(_r43);
      const row_r45 = ctx_r43.$implicit;
      const index_r46 = ctx_r43.index;
      const dataIndex_r47 = ctx_r43.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._selectRow($event, row_r45, ctx_r0._getIndex(index_r46, dataIndex_r47)));
    })("contextmenu", function MtxGrid_Conditional_7_Conditional_5_tr_0_Template_tr_contextmenu_0_listener($event) {
      const ctx_r47 = ɵɵrestoreView(_r43);
      const row_r45 = ctx_r47.$implicit;
      const index_r46 = ctx_r47.index;
      const dataIndex_r47 = ctx_r47.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._contextmenu($event, row_r45, ctx_r0._getIndex(index_r46, dataIndex_r47)));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r45 = ctx.$implicit;
    const index_r46 = ctx.index;
    const dataIndex_r47 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ɵɵpipeBind4(1, 4, row_r45, index_r46, dataIndex_r47, ctx_r0.rowClassFormatter));
    ɵɵclassProp("selected", ctx_r0.rowSelection.isSelected(row_r45));
  }
}
function MtxGrid_Conditional_7_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_Conditional_5_tr_0_Template, 2, 9, "tr", 59);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matRowDefColumns", ctx_r0.displayedColumns);
  }
}
function MtxGrid_Conditional_7_Conditional_6_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 28);
  }
}
function MtxGrid_Conditional_7_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_Conditional_6_tr_0_Template, 1, 0, "tr", 61);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matFooterRowDef", ctx_r0.displayedColumns)("matFooterRowDefSticky", true);
  }
}
function MtxGrid_Conditional_7_Conditional_7_td_1_ng_template_2_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_Conditional_7_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 65)(1, "div", 66);
    ɵɵtemplate(2, MtxGrid_Conditional_7_Conditional_7_td_1_ng_template_2_Template, 0, 0, "ng-template", 44);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r49 = ctx.$implicit;
    const dataIndex_r50 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵattribute("colspan", ctx_r0.displayedColumns.length);
    ɵɵadvance();
    ɵɵproperty("@expansion", ctx_r0.expansionRowStates[dataIndex_r50].expanded ? "expanded" : "collapsed");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.expansionTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(4, _c13, row_r49, row_r49, dataIndex_r50, ctx_r0.expansionRowStates[dataIndex_r50].expanded));
  }
}
function MtxGrid_Conditional_7_Conditional_7_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 67);
  }
  if (rf & 2) {
    const dataIndex_r51 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ctx_r0.expansionRowStates[dataIndex_r51].expanded ? "expanded" : "collapsed");
  }
}
function MtxGrid_Conditional_7_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 62);
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_7_td_1_Template, 3, 9, "td", 63);
    ɵɵelementContainerEnd();
    ɵɵtemplate(2, MtxGrid_Conditional_7_Conditional_7_tr_2_Template, 1, 2, "tr", 64);
  }
  if (rf & 2) {
    ɵɵadvance(2);
    ɵɵproperty("matRowDefColumns", ɵɵpureFunction0(1, _c12));
  }
}
function MtxGrid_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 68);
    ɵɵlistener("matSortChange", function MtxGrid_Conditional_7_Template_table_matSortChange_0_listener($event) {
      ɵɵrestoreView(_r28);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onSortChange($event));
    });
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_1_Template, 4, 0, "ng-container", 24);
    ɵɵrepeaterCreate(2, MtxGrid_Conditional_7_For_3_Template, 4, 3, "ng-container", 25, ɵɵrepeaterTrackByIdentity);
    ɵɵtemplate(4, MtxGrid_Conditional_7_Conditional_4_Template, 1, 2, "tr", 26)(5, MtxGrid_Conditional_7_Conditional_5_Template, 1, 1, "tr", 27)(6, MtxGrid_Conditional_7_Conditional_6_Template, 1, 2, "tr", 28)(7, MtxGrid_Conditional_7_Conditional_7_Template, 3, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ɵɵpureFunction3(15, _c6, ctx_r0.rowHover, ctx_r0.rowStriped, ctx_r0.expandable));
    ɵɵproperty("dataSource", ctx_r0.dataSource)("multiTemplateDataRows", ctx_r0.expandable)("matSortActive", ctx_r0.sortActive)("matSortDirection", ctx_r0.sortDirection)("matSortDisableClear", ctx_r0.sortDisableClear)("matSortDisabled", ctx_r0.sortDisabled)("matSortStart", ctx_r0.sortStart)("trackBy", ctx_r0.trackBy);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.rowSelectable && !ctx_r0.hideRowSelectionCheckbox ? 1 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.columns);
    ɵɵadvance(2);
    ɵɵconditional(!ctx_r0.useContentHeaderRowTemplate ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.useContentRowTemplate ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0._whetherShowSummary ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.expandable ? 7 : -1);
  }
}
function MtxGrid_Conditional_8_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_8_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_8_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.noResultTemplate);
  }
}
function MtxGrid_Conditional_8_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r0.noResultText, " ");
  }
}
function MtxGrid_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtemplate(1, MtxGrid_Conditional_8_Conditional_1_Template, 1, 1, null, 15)(2, MtxGrid_Conditional_8_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.noResultTemplate ? 1 : 2);
  }
}
function MtxGrid_Conditional_9_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_9_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.sidebarTemplate);
  }
}
function MtxGrid_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtemplate(1, MtxGrid_Conditional_9_Conditional_1_Template, 1, 1, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.sidebarTemplate ? 1 : -1);
  }
}
function MtxGrid_Conditional_11_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_11_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_11_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.statusbarTemplate);
  }
}
function MtxGrid_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, MtxGrid_Conditional_11_Conditional_1_Template, 1, 1, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.statusbarTemplate ? 1 : -1);
  }
}
function MtxGrid_Conditional_13_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_13_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.paginationTemplate);
  }
}
function MtxGrid_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r52 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-paginator", 71);
    ɵɵlistener("page", function MtxGrid_Conditional_14_Template_mat_paginator_page_0_listener($event) {
      ɵɵrestoreView(_r52);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onPage($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("mat-paginator-hidden", !ctx_r0.showPaginator);
    ɵɵproperty("showFirstLastButtons", ctx_r0.showFirstLastButtons)("length", ctx_r0.length)("pageIndex", ctx_r0.pageIndex)("pageSize", ctx_r0.pageSize)("pageSizeOptions", ctx_r0.pageSizeOptions)("hidePageSize", ctx_r0.hidePageSize)("disabled", ctx_r0.pageDisabled);
  }
}
function MtxGrid_ng_template_15_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_ng_template_15_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_ng_template_15_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r52 = ɵɵnextContext();
    const headerExtraTemplate_r54 = ctx_r52.$implicit;
    const col_r55 = ctx_r52.colDef;
    ɵɵproperty("ngTemplateOutlet", headerExtraTemplate_r54)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c8, col_r55, col_r55));
  }
}
function MtxGrid_ng_template_15_Conditional_2_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_ng_template_15_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_ng_template_15_Conditional_2_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 44);
  }
  if (rf & 2) {
    const ctx_r52 = ɵɵnextContext(2);
    const headerExtraTemplate_r54 = ctx_r52.$implicit;
    const col_r55 = ctx_r52.colDef;
    ɵɵproperty("ngTemplateOutlet", headerExtraTemplate_r54[col_r55.field])("ngTemplateOutletContext", ɵɵpureFunction2(2, _c8, col_r55, col_r55));
  }
}
function MtxGrid_ng_template_15_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_ng_template_15_Conditional_2_Conditional_0_Template, 1, 5, null, 44);
    ɵɵpipe(1, "isTemplateRef");
  }
  if (rf & 2) {
    const ctx_r52 = ɵɵnextContext();
    const headerExtraTemplate_r54 = ctx_r52.$implicit;
    const col_r55 = ctx_r52.colDef;
    ɵɵconditional(ɵɵpipeBind1(1, 1, headerExtraTemplate_r54 == null ? null : headerExtraTemplate_r54[col_r55.field]) ? 0 : -1);
  }
}
function MtxGrid_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_ng_template_15_Conditional_0_Template, 1, 5, null, 44);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵtemplate(2, MtxGrid_ng_template_15_Conditional_2_Template, 2, 3);
  }
  if (rf & 2) {
    const headerExtraTemplate_r54 = ctx.$implicit;
    ɵɵconditional(ɵɵpipeBind1(1, 1, headerExtraTemplate_r54) ? 0 : 2);
  }
}
var MatFlexTableResizeStrategy = class _MatFlexTableResizeStrategy extends CdkFlexTableResizeStrategy {
  constructor(columnResize, styleScheduler, table, document, nonce) {
    super(columnResize, styleScheduler, table, document, nonce);
  }
  getColumnCssClass(cssFriendlyColumnName) {
    return `mat-column-${cssFriendlyColumnName}`;
  }
  static {
    this.ɵfac = function MatFlexTableResizeStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatFlexTableResizeStrategy)(ɵɵinject(ColumnResize), ɵɵinject(_COALESCED_STYLE_SCHEDULER), ɵɵinject(CdkTable), ɵɵinject(DOCUMENT), ɵɵinject(CSP_NONCE, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _MatFlexTableResizeStrategy,
      factory: _MatFlexTableResizeStrategy.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatFlexTableResizeStrategy, [{
    type: Injectable
  }], () => [{
    type: ColumnResize
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: CdkTable
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }, {
      type: Optional
    }]
  }], null);
})();
var FLEX_RESIZE_STRATEGY_PROVIDER2 = {
  provide: ResizeStrategy,
  useClass: MatFlexTableResizeStrategy
};
var PROVIDERS2 = [ColumnResizeNotifier, HeaderRowEventDispatcher, ColumnResizeNotifierSource];
var TABLE_PROVIDERS2 = [...PROVIDERS2, TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER];
var FLEX_PROVIDERS2 = [...PROVIDERS2, FLEX_RESIZE_STRATEGY_PROVIDER2];
var TABLE_HOST_BINDINGS = {
  class: "mat-column-resize-table"
};
var FLEX_HOST_BINDINGS = {
  class: "mat-column-resize-flex"
};
var AbstractMatColumnResize = class extends ColumnResize {
  getTableHeight() {
    const table = this.elementRef.nativeElement;
    const tableParent = table.parentNode;
    const isTableContainer = tableParent.classList.contains("mat-table-container");
    return isTableContainer ? tableParent.offsetHeight : table.offsetHeight;
  }
};
var MatColumnResize = class _MatColumnResize extends AbstractMatColumnResize {
  constructor(columnResizeNotifier, elementRef, eventDispatcher, ngZone, notifier) {
    super();
    this.columnResizeNotifier = columnResizeNotifier;
    this.elementRef = elementRef;
    this.eventDispatcher = eventDispatcher;
    this.ngZone = ngZone;
    this.notifier = notifier;
  }
  static {
    this.ɵfac = function MatColumnResize_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatColumnResize)(ɵɵdirectiveInject(ColumnResizeNotifier), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(HeaderRowEventDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ColumnResizeNotifierSource));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatColumnResize,
      selectors: [["table", "mat-table", "", "columnResize", ""]],
      hostAttrs: [1, "mat-column-resize-table"],
      standalone: true,
      features: [ɵɵProvidersFeature([...TABLE_PROVIDERS2, {
        provide: ColumnResize,
        useExisting: _MatColumnResize
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResize, [{
    type: Directive,
    args: [{
      selector: "table[mat-table][columnResize]",
      host: TABLE_HOST_BINDINGS,
      providers: [...TABLE_PROVIDERS2, {
        provide: ColumnResize,
        useExisting: MatColumnResize
      }],
      standalone: true
    }]
  }], () => [{
    type: ColumnResizeNotifier
  }, {
    type: ElementRef
  }, {
    type: HeaderRowEventDispatcher
  }, {
    type: NgZone
  }, {
    type: ColumnResizeNotifierSource
  }], null);
})();
var MatColumnResizeFlex = class _MatColumnResizeFlex extends AbstractMatColumnResize {
  constructor(columnResizeNotifier, elementRef, eventDispatcher, ngZone, notifier) {
    super();
    this.columnResizeNotifier = columnResizeNotifier;
    this.elementRef = elementRef;
    this.eventDispatcher = eventDispatcher;
    this.ngZone = ngZone;
    this.notifier = notifier;
  }
  static {
    this.ɵfac = function MatColumnResizeFlex_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatColumnResizeFlex)(ɵɵdirectiveInject(ColumnResizeNotifier), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(HeaderRowEventDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ColumnResizeNotifierSource));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatColumnResizeFlex,
      selectors: [["mat-table", "columnResize", ""]],
      hostAttrs: [1, "mat-column-resize-flex"],
      standalone: true,
      features: [ɵɵProvidersFeature([...FLEX_PROVIDERS2, {
        provide: ColumnResize,
        useExisting: _MatColumnResizeFlex
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeFlex, [{
    type: Directive,
    args: [{
      selector: "mat-table[columnResize]",
      host: FLEX_HOST_BINDINGS,
      providers: [...FLEX_PROVIDERS2, {
        provide: ColumnResize,
        useExisting: MatColumnResizeFlex
      }],
      standalone: true
    }]
  }], () => [{
    type: ColumnResizeNotifier
  }, {
    type: ElementRef
  }, {
    type: HeaderRowEventDispatcher
  }, {
    type: NgZone
  }, {
    type: ColumnResizeNotifierSource
  }], null);
})();
var MatColumnResizeOverlayHandle = class _MatColumnResizeOverlayHandle extends ResizeOverlayHandle {
  constructor(columnDef, columnResize, directionality, elementRef, eventDispatcher, ngZone, resizeNotifier, resizeRef, styleScheduler, document) {
    super();
    this.columnDef = columnDef;
    this.columnResize = columnResize;
    this.directionality = directionality;
    this.elementRef = elementRef;
    this.eventDispatcher = eventDispatcher;
    this.ngZone = ngZone;
    this.resizeNotifier = resizeNotifier;
    this.resizeRef = resizeRef;
    this.styleScheduler = styleScheduler;
    this.document = document;
  }
  updateResizeActive(active) {
    super.updateResizeActive(active);
    const originHeight = this.resizeRef.origin.nativeElement.offsetHeight;
    this.topElement.nativeElement.style.height = `${originHeight}px`;
    this.resizeRef.overlayRef.updateSize({
      height: active ? this.columnResize.getTableHeight() : originHeight
    });
  }
  static {
    this.ɵfac = function MatColumnResizeOverlayHandle_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatColumnResizeOverlayHandle)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ColumnResize), ɵɵdirectiveInject(Directionality), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(HeaderRowEventDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ColumnResizeNotifierSource), ɵɵdirectiveInject(ResizeRef), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(DOCUMENT));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatColumnResizeOverlayHandle,
      selectors: [["ng-component"]],
      viewQuery: function MatColumnResizeOverlayHandle_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c0, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.topElement = _t.first);
        }
      },
      hostAttrs: [1, "mat-column-resize-overlay-thumb"],
      standalone: true,
      features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
      decls: 2,
      vars: 0,
      consts: [["top", ""], [1, "mat-column-resize-overlay-thumb-top"]],
      template: function MatColumnResizeOverlayHandle_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "div", 1, 0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeOverlayHandle, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "mat-column-resize-overlay-thumb"
      },
      template: '<div #top class="mat-column-resize-overlay-thumb-top"></div>',
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ColumnResize
  }, {
    type: Directionality
  }, {
    type: ElementRef
  }, {
    type: HeaderRowEventDispatcher
  }, {
    type: NgZone
  }, {
    type: ColumnResizeNotifierSource
  }, {
    type: ResizeRef
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    topElement: [{
      type: ViewChild,
      args: ["top", {
        static: true
      }]
    }]
  });
})();
var AbstractMatResizable = class extends Resizable {
  constructor() {
    super(...arguments);
    this.minWidthPxInternal = 32;
  }
  getInlineHandleCssClassName() {
    return "mat-resizable-handle";
  }
  getOverlayHandleComponentType() {
    return MatColumnResizeOverlayHandle;
  }
};
var RESIZABLE_HOST_BINDINGS = {
  class: "mat-resizable"
};
var RESIZABLE_INPUTS = ["minWidthPx: matResizableMinWidthPx", "maxWidthPx: matResizableMaxWidthPx"];
var MatResizable = class _MatResizable extends AbstractMatResizable {
  get hasResizableClass() {
    return this.isResizable ? RESIZABLE_HOST_BINDINGS.class : "";
  }
  get resizable() {
    return this.isResizable;
  }
  set resizable(newValue) {
    this.isResizable = newValue == null || newValue === "" || newValue;
  }
  constructor(columnDef, columnResize, directionality, document, elementRef, eventDispatcher, injector, ngZone, overlay, resizeNotifier, resizeStrategy, styleScheduler, viewContainerRef, changeDetectorRef) {
    super();
    this.columnDef = columnDef;
    this.columnResize = columnResize;
    this.directionality = directionality;
    this.elementRef = elementRef;
    this.eventDispatcher = eventDispatcher;
    this.injector = injector;
    this.ngZone = ngZone;
    this.overlay = overlay;
    this.resizeNotifier = resizeNotifier;
    this.resizeStrategy = resizeStrategy;
    this.styleScheduler = styleScheduler;
    this.viewContainerRef = viewContainerRef;
    this.changeDetectorRef = changeDetectorRef;
    this.isResizable = true;
    this.document = document;
  }
  static {
    this.ɵfac = function MatResizable_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatResizable)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ColumnResize), ɵɵdirectiveInject(Directionality), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(HeaderRowEventDispatcher), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Overlay), ɵɵdirectiveInject(ColumnResizeNotifierSource), ɵɵdirectiveInject(ResizeStrategy), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatResizable,
      selectors: [["mat-header-cell", "resizable", ""], ["th", "mat-header-cell", "", "resizable", ""]],
      hostAttrs: [1, "mat-resizable"],
      hostVars: 2,
      hostBindings: function MatResizable_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.hasResizableClass);
        }
      },
      inputs: {
        minWidthPx: [0, "matResizableMinWidthPx", "minWidthPx"],
        maxWidthPx: [0, "matResizableMaxWidthPx", "maxWidthPx"],
        resizable: "resizable"
      },
      standalone: true,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatResizable, [{
    type: Directive,
    args: [{
      selector: "mat-header-cell[resizable], th[mat-header-cell][resizable]",
      host: RESIZABLE_HOST_BINDINGS,
      inputs: RESIZABLE_INPUTS,
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ColumnResize
  }, {
    type: Directionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: ElementRef
  }, {
    type: HeaderRowEventDispatcher
  }, {
    type: Injector
  }, {
    type: NgZone
  }, {
    type: Overlay
  }, {
    type: ColumnResizeNotifierSource
  }, {
    type: ResizeStrategy
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }], {
    hasResizableClass: [{
      type: HostBinding,
      args: ["class"]
    }],
    resizable: [{
      type: Input
    }]
  });
})();
var ENTRY_COMMON_COMPONENTS = [MatColumnResizeOverlayHandle];
var MatColumnResizeCommonModule = class _MatColumnResizeCommonModule {
  static {
    this.ɵfac = function MatColumnResizeCommonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatColumnResizeCommonModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatColumnResizeCommonModule,
      imports: [MatColumnResizeOverlayHandle],
      exports: [MatColumnResizeOverlayHandle]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeCommonModule, [{
    type: NgModule,
    args: [{
      imports: ENTRY_COMMON_COMPONENTS,
      exports: ENTRY_COMMON_COMPONENTS
    }]
  }], null, null);
})();
var IMPORTS = [MatCommonModule, OverlayModule, MatColumnResizeCommonModule];
var MatColumnResizeModule = class _MatColumnResizeModule {
  static {
    this.ɵfac = function MatColumnResizeModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MatColumnResizeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatColumnResizeModule,
      imports: [MatCommonModule, OverlayModule, MatColumnResizeCommonModule, MatColumnResize, MatColumnResizeFlex, MatResizable],
      exports: [MatColumnResize, MatColumnResizeFlex, MatResizable]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [IMPORTS]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeModule, [{
    type: NgModule,
    args: [{
      imports: [...IMPORTS, MatColumnResize, MatColumnResizeFlex, MatResizable],
      exports: [MatColumnResize, MatColumnResizeFlex, MatResizable]
    }]
  }], null, null);
})();
var MtxGridUtils = class _MtxGridUtils {
  constructor() {
  }
  /**
   * Get cell's value based on the data and column's field (e.g. `a.b.c`)
   * @param rowData Row data
   * @param colDef Column definition
   * @returns
   */
  getCellValue(rowData, colDef) {
    const keyArr = colDef.field ? colDef.field.split(".") : [];
    let tmp = "";
    keyArr.forEach((key, i) => {
      if (i === 0) {
        tmp = rowData[key];
      } else {
        tmp = tmp && tmp[key];
      }
    });
    return tmp;
  }
  /**
   * Get all data of a col
   * @param data All data
   * @param colDef Column definition
   * @returns
   */
  getColData(data, colDef) {
    return data.map((rowData) => this.getCellValue(rowData, colDef));
  }
  /**
   * Whether the value is empty (`null`, `undefined`, `''`, `[]`)
   * @param value
   * @returns
   */
  isEmpty(value) {
    return value == null || value.toString() === "";
  }
  /**
   * Whether the value contain HTML
   * @param value
   * @returns
   */
  isContainHTML(value) {
    return /<\/?[a-z][\s\S]*>/i.test(value);
  }
  static {
    this.ɵfac = function MtxGridUtils_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridUtils)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _MtxGridUtils,
      factory: _MtxGridUtils.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridUtils, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var MtxGridColClassPipe = class _MtxGridColClassPipe {
  transform(colDef, rowData, rowChangeRecord, currentValue) {
    if (typeof colDef.class === "string") {
      return colDef.class;
    } else if (typeof colDef.class === "function") {
      return colDef.class(rowData, colDef);
    }
    return "";
  }
  static {
    this.ɵfac = function MtxGridColClassPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridColClassPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "colClass",
      type: _MtxGridColClassPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridColClassPipe, [{
    type: Pipe,
    args: [{
      name: "colClass",
      standalone: true
    }]
  }], null, null);
})();
var MtxGridRowClassPipe = class _MtxGridRowClassPipe {
  transform(rowData, index, dataIndex, rowClassFormatter) {
    const rowIndex = index === void 0 ? dataIndex : index;
    const classList = rowIndex % 2 === 1 ? ["mat-row-odd"] : [];
    if (rowClassFormatter) {
      for (const key of Object.keys(rowClassFormatter)) {
        if (rowClassFormatter[key](rowData, rowIndex)) {
          classList.push(key);
        }
      }
    }
    return classList.join(" ");
  }
  static {
    this.ɵfac = function MtxGridRowClassPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridRowClassPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "rowClass",
      type: _MtxGridRowClassPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridRowClassPipe, [{
    type: Pipe,
    args: [{
      name: "rowClass",
      standalone: true
    }]
  }], null, null);
})();
var MtxGridCellActionsPipe = class _MtxGridCellActionsPipe {
  transform(btns, rowData, rowChangeRecord, currentValue) {
    if (typeof btns === "function") {
      return btns(rowData);
    } else if (Array.isArray(btns)) {
      return btns;
    }
    return [];
  }
  static {
    this.ɵfac = function MtxGridCellActionsPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridCellActionsPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "cellActions",
      type: _MtxGridCellActionsPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionsPipe, [{
    type: Pipe,
    args: [{
      name: "cellActions",
      standalone: true
    }]
  }], null, null);
})();
var MtxGridCellActionTooltipPipe = class _MtxGridCellActionTooltipPipe {
  transform(btn) {
    if (typeof btn.tooltip === "string" || isObservable(btn.tooltip)) {
      return {
        message: btn.tooltip
      };
    } else {
      return btn.tooltip || {
        message: ""
      };
    }
  }
  static {
    this.ɵfac = function MtxGridCellActionTooltipPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridCellActionTooltipPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "cellActionTooltip",
      type: _MtxGridCellActionTooltipPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionTooltipPipe, [{
    type: Pipe,
    args: [{
      name: "cellActionTooltip",
      standalone: true
    }]
  }], null, null);
})();
var MtxGridCellActionBadgePipe = class _MtxGridCellActionBadgePipe {
  transform(btn) {
    if (typeof btn.badge === "number" || typeof btn.badge === "string" || isObservable(btn.badge)) {
      return {
        content: btn.badge
      };
    } else {
      return btn.badge || {
        content: ""
      };
    }
  }
  static {
    this.ɵfac = function MtxGridCellActionBadgePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridCellActionBadgePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "cellActionBadge",
      type: _MtxGridCellActionBadgePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionBadgePipe, [{
    type: Pipe,
    args: [{
      name: "cellActionBadge",
      standalone: true
    }]
  }], null, null);
})();
var MtxGridCellActionDisablePipe = class _MtxGridCellActionDisablePipe {
  transform(btn, rowData, rowChangeRecord, currentValue) {
    if (typeof btn.disabled === "boolean") {
      return btn.disabled;
    } else if (typeof btn.disabled === "function") {
      return btn.disabled(rowData);
    } else {
      return false;
    }
  }
  static {
    this.ɵfac = function MtxGridCellActionDisablePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridCellActionDisablePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "cellActionDisable",
      type: _MtxGridCellActionDisablePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionDisablePipe, [{
    type: Pipe,
    args: [{
      name: "cellActionDisable",
      standalone: true
    }]
  }], null, null);
})();
var MtxGridCellSummaryPipe = class _MtxGridCellSummaryPipe {
  constructor(utils) {
    this.utils = utils;
  }
  transform(data, colDef) {
    if (typeof colDef.summary === "string") {
      return colDef.summary;
    } else if (typeof colDef.summary === "function") {
      return colDef.summary(this.utils.getColData(data, colDef), colDef);
    }
  }
  static {
    this.ɵfac = function MtxGridCellSummaryPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridCellSummaryPipe)(ɵɵdirectiveInject(MtxGridUtils, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "cellSummary",
      type: _MtxGridCellSummaryPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellSummaryPipe, [{
    type: Pipe,
    args: [{
      name: "cellSummary",
      standalone: true
    }]
  }], () => [{
    type: MtxGridUtils
  }], null);
})();
var MtxGridCell = class _MtxGridCell {
  get _value() {
    return this._utils.getCellValue(this.rowData, this.colDef);
  }
  constructor(_dialog, _utils, _differs, _changeDetectorRef) {
    this._dialog = _dialog;
    this._utils = _utils;
    this._differs = _differs;
    this._changeDetectorRef = _changeDetectorRef;
    this.rowData = {};
    this.data = [];
    this.summary = false;
    this.placeholder = "--";
    this.rowDataChange = new EventEmitter();
  }
  ngOnInit() {
    this.rowDataDiffer = this._differs.find(this.rowData).create();
  }
  ngDoCheck() {
    const changes = this.rowDataDiffer?.diff(this.rowData);
    if (changes) {
      this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    changes.forEachChangedItem((record) => {
      this.rowChangeRecord = record;
      this.rowDataChange.emit(record);
      this._changeDetectorRef.markForCheck();
    });
  }
  _getText(value) {
    return value === void 0 ? "" : this._utils.isEmpty(value) ? this.placeholder : value;
  }
  _getTooltip(value) {
    return this._utils.isEmpty(value) ? "" : value;
  }
  _getFormatterTooltip(value) {
    return this._utils.isContainHTML(value) || this._utils.isEmpty(value) ? "" : value;
  }
  _onActionClick(event, btn, rowData) {
    event.preventDefault();
    event.stopPropagation();
    if (typeof btn.pop === "string" || isObservable(btn.pop)) {
      this._dialog.open({
        title: btn.pop,
        buttons: [{
          color: "primary",
          text: "OK",
          onClick: () => btn.click?.(rowData) || {}
        }, {
          text: "CLOSE"
        }]
      });
    } else if (typeof btn.pop === "object") {
      this._dialog.open({
        title: btn.pop?.title,
        description: btn.pop?.description,
        buttons: [{
          color: btn.pop?.okColor || "primary",
          text: btn.pop?.okText || "OK",
          onClick: () => btn.click?.(rowData) || {}
        }, {
          color: btn.pop?.closeColor,
          text: btn.pop?.closeText || "CLOSE"
        }]
      });
    } else {
      btn.click?.(rowData);
    }
  }
  static {
    this.ɵfac = function MtxGridCell_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridCell)(ɵɵdirectiveInject(MtxDialog), ɵɵdirectiveInject(MtxGridUtils), ɵɵdirectiveInject(KeyValueDiffers), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MtxGridCell,
      selectors: [["mtx-grid-cell"]],
      inputs: {
        rowData: "rowData",
        colDef: "colDef",
        data: "data",
        summary: "summary",
        placeholder: "placeholder"
      },
      outputs: {
        rowDataChange: "rowDataChange"
      },
      exportAs: ["mtxGridCell"],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 2,
      vars: 1,
      consts: [[3, "title", "innerHTML"], ["target", "_blank", 3, "href"], [1, "mtx-grid-img", 3, "src"], [3, "title"], ["mat-raised-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-stroked-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-flat-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-icon-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-fab", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-mini-fab", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-raised-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], [1, "mtx-grid-icon"], ["mat-stroked-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-flat-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-icon-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-fab", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-mini-fab", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["mat-button", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["color", "primary"]],
      template: function MtxGridCell_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, MtxGridCell_Conditional_0_Template, 3, 8, "span", 0)(1, MtxGridCell_Conditional_1_Template, 2, 1);
        }
        if (rf & 2) {
          ɵɵconditional(ctx.summary ? 0 : 1);
        }
      },
      dependencies: [AsyncPipe, CurrencyPipe, DatePipe, DecimalPipe, PercentPipe, MatButton, MatIconButton, MatFabButton, MatMiniFabButton, MatIcon, MatChipListbox, MatChip, MatTooltip, MatBadge, MtxToObservablePipe, MtxGridCellActionsPipe, MtxGridCellSummaryPipe, MtxGridCellActionDisablePipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe],
      styles: [".mtx-grid-img{display:inline-block;width:32px;border-radius:4px;vertical-align:middle}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCell, [{
    type: Component,
    args: [{
      selector: "mtx-grid-cell",
      exportAs: "mtxGridCell",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [AsyncPipe, CurrencyPipe, DatePipe, DecimalPipe, PercentPipe, MatButton, MatIconButton, MatFabButton, MatMiniFabButton, MatIcon, MatChipListbox, MatChip, MatTooltip, MatBadge, MtxToObservablePipe, MtxGridCellActionsPipe, MtxGridCellSummaryPipe, MtxGridCellActionDisablePipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe],
      template: `@if (summary) {
  <span
    [title]="_getFormatterTooltip((data | cellSummary: colDef))"
    [innerHTML]="_getText((data | cellSummary: colDef))">
  </span>
} @else {
  <!-- Custom formatting -->
  @if (colDef.formatter) {
    <span
      [title]="_getFormatterTooltip(colDef.formatter(rowData, colDef))"
      [innerHTML]="_getText(colDef.formatter(rowData, colDef))">
    </span>
  } @else {
    <!-- Default formatting -->
    @switch (colDef.type) {
      <!-- Buttons -->
      @case ('button') {
        @for (btn of colDef.buttons | cellActions: rowData: rowChangeRecord: rowChangeRecord?.currentValue; track btn) {
          @if (!btn.iif || btn.iif(rowData)) {
            @switch (btn.type) {
              @case ('raised') {
                <button mat-raised-button [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  @if (btn.icon) {
                    <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                  }
                  <span>{{btn.text | toObservable | async}}</span>
                </button>
              }
              @case ('stroked') {
                <button mat-stroked-button [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  @if (btn.icon) {
                    <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                  }
                  <span>{{btn.text | toObservable | async}}</span>
                </button>
              }
              @case ('flat') {
                <button mat-flat-button [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  @if (btn.icon) {
                    <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                  }
                  <span>{{btn.text | toObservable | async}}</span>
                </button>
              }
              @case ('icon') {
                <button mat-icon-button [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                </button>
              }
              @case ('fab') {
                <button mat-fab [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                </button>
              }
              @case ('mini-fab') {
                <button mat-mini-fab [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                </button>
              }
              @default {
                <button mat-button [color]="btn.color || 'primary'" type="button"
                  class="mtx-grid-action-button" [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData: rowChangeRecord: rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)">
                  @if (btn.icon) {
                    <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
                  }
                  <span>{{btn.text | toObservable | async}}</span>
                </button>
              }
            }
          }
        }
      }
      <!-- Tag -->
      @case ('tag') {
        @if (colDef.tag && colDef.tag[_value]) {
          <mat-chip-listbox>
            <mat-chip color="primary" [class]="'bg-' + colDef.tag[_value].color">
              {{colDef.tag[_value].text}}
            </mat-chip>
          </mat-chip-listbox>
        } @else {
          {{_value}}
        }
      }
      <!-- Link -->
      @case ('link') {
        <a [href]="_value" target="_blank">{{_value}}</a>
      }
      <!-- Image -->
      @case ('image') {
        <img class="mtx-grid-img" [src]="_value">
      }
      <!-- Boolean -->
      @case ('boolean') {
        <span [title]="_getTooltip(_value)">{{_getText(_value)}}</span>
      }
      <!-- Number -->
      @case ('number') {
        <span [title]="_getTooltip(_value | number: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)">
          {{_getText(_value | number: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Currency -->
      @case ('currency') {
        <span [title]="_getTooltip(_value | currency: colDef.typeParameter?.currencyCode: colDef.typeParameter?.display: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)">
          {{_getText(_value | currency: colDef.typeParameter?.currencyCode: colDef.typeParameter?.display: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Percent -->
      @case ('percent') {
        <span [title]="_getTooltip(_value | percent: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)">
          {{_getText(_value | percent: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Date -->
      @case ('date') {
        <span [title]="_getTooltip(_value | date: colDef.typeParameter?.format: colDef.typeParameter?.timezone: colDef.typeParameter?.locale)">
          {{_getText(_value | date: colDef.typeParameter?.format: colDef.typeParameter?.timezone: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Default -->
      @default {
        <span [title]="_getTooltip(_value)">{{_getText(_value)}}</span>
      }
    }
  }
}
`,
      styles: [".mtx-grid-img{display:inline-block;width:32px;border-radius:4px;vertical-align:middle}\n"]
    }]
  }], () => [{
    type: MtxDialog
  }, {
    type: MtxGridUtils
  }, {
    type: KeyValueDiffers
  }, {
    type: ChangeDetectorRef
  }], {
    rowData: [{
      type: Input
    }],
    colDef: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    summary: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    rowDataChange: [{
      type: Output
    }]
  });
})();
var MtxGridColumnMenu = class _MtxGridColumnMenu {
  constructor() {
    this.columns = [];
    this.selectable = true;
    this.selectableChecked = "show";
    this.sortable = true;
    this.pinnable = true;
    this._buttonText = "";
    this.buttonType = "stroked";
    this.buttonClass = "";
    this.buttonIcon = "";
    this.showHeader = false;
    this.headerText = "Columns Header";
    this.showFooter = false;
    this.footerText = "Columns Footer";
    this.columnChange = new EventEmitter();
    this._pinOptions = [{
      label: "Pin Left",
      value: "left"
    }, {
      label: "Pin Right",
      value: "right"
    }, {
      label: "No Pin",
      value: null
    }];
  }
  get buttonText() {
    const defaultText = `Columns ${this.selectableChecked === "show" ? "Shown" : "Hidden"}`;
    return this._buttonText ? this._buttonText : defaultText;
  }
  set buttonText(value) {
    this._buttonText = value;
  }
  get pinOptions() {
    return this._pinOptions;
  }
  set pinOptions(value) {
    if (value.length > 0) {
      this._pinOptions = value;
    }
  }
  _handleDroped(e) {
    moveItemInArray(this.columns, e.previousIndex, e.currentIndex);
    this.columnChange.emit(this.columns);
  }
  _handleChecked(col) {
    if (this.selectableChecked === "show") {
      col.hide = !col.show;
    } else {
      col.show = !col.hide;
    }
    this.columnChange.emit(this.columns);
  }
  _handlePinSelect(col, val) {
    if (col.pinned != val) {
      col.pinned = val;
      this.columnChange.emit(this.columns);
    }
  }
  static {
    this.ɵfac = function MtxGridColumnMenu_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridColumnMenu)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MtxGridColumnMenu,
      selectors: [["mtx-grid-column-menu"]],
      viewQuery: function MtxGridColumnMenu_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c2, 7);
          ɵɵviewQuery(MatMenuTrigger, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuPanel = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuTrigger = _t.first);
        }
      },
      inputs: {
        columns: "columns",
        selectable: "selectable",
        selectableChecked: "selectableChecked",
        sortable: "sortable",
        pinnable: "pinnable",
        buttonText: "buttonText",
        buttonType: "buttonType",
        buttonColor: "buttonColor",
        buttonClass: "buttonClass",
        buttonIcon: "buttonIcon",
        showHeader: "showHeader",
        headerText: "headerText",
        headerTemplate: "headerTemplate",
        showFooter: "showFooter",
        footerText: "footerText",
        footerTemplate: "footerTemplate",
        pinOptions: "pinOptions"
      },
      outputs: {
        columnChange: "columnChange"
      },
      exportAs: ["mtxGridColumnMenu"],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 17,
      vars: 5,
      consts: [["menu", "matMenu"], ["checkboxList", ""], ["pinList", "matMenu"], ["mat-raised-button", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["mat-stroked-button", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["mat-flat-button", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["mat-icon-button", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["mat-fab", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["mat-mini-fab", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["mat-button", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], [1, "mtx-grid-column-menu"], [1, "mtx-grid-column-menu-content", 3, "click", "keydown"], [1, "mtx-grid-column-menu-header"], [1, "mtx-grid-column-menu-body"], ["cdkDropList", "", 1, "mtx-grid-column-menu-list"], [1, "mtx-grid-column-menu-list"], [1, "mtx-grid-column-menu-footer"], ["mat-raised-button", "", "type", "button", 3, "color", "matMenuTriggerFor"], ["mat-stroked-button", "", "type", "button", 3, "color", "matMenuTriggerFor"], ["mat-flat-button", "", "type", "button", 3, "color", "matMenuTriggerFor"], ["mat-icon-button", "", "type", "button", 3, "color", "matMenuTriggerFor"], ["mat-fab", "", "type", "button", 3, "color", "matMenuTriggerFor"], ["mat-mini-fab", "", "type", "button", 3, "color", "matMenuTriggerFor"], ["mat-button", "", "type", "button", 3, "color", "matMenuTriggerFor"], [3, "ngTemplateOutlet"], ["cdkDropList", "", 1, "mtx-grid-column-menu-list", 3, "cdkDropListDropped"], ["cdkDrag", "", 1, "mtx-grid-column-menu-item", 3, "cdkDragDisabled"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-drag-handle-icon"], ["d", "M7,19V17H9V19H7M11,19V17H13V19H11M15,19V17H17V19H15M7,15V13H9V15H7M11,15V13H13V15H11M15,15V13H17V15H15M7,11V9H9V11H7M11,11V9H13V11H11M15,11V9H17V11H15M7,7V5H9V7H7M11,7V5H13V7H11M15,7V5H17V7H15Z"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mtx-grid-column-menu-item"], [1, "mtx-grid-column-menu-item-label", 3, "ngModel", "disabled"], [1, "mtx-grid-column-menu-item-label"], ["mat-icon-button", "", "type", "button", 1, "mtx-grid-column-pin-button", 3, "matMenuTriggerFor"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-pin-icon"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-pin-off-icon"], [1, "mtx-grid-column-pin-list"], ["type", "button", "mat-menu-item", "", 1, "mtx-grid-column-pin-option"], ["d", "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z"], ["d", "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z"], ["type", "button", "mat-menu-item", "", 1, "mtx-grid-column-pin-option", 3, "click"], [1, "mtx-grid-column-pin-option-placeholder"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-pin-check-icon"], [1, "mtx-grid-column-pin-option-text"], ["d", "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"], [1, "mtx-grid-column-menu-item-label", 3, "ngModelChange", "change", "ngModel", "disabled"]],
      template: function MtxGridColumnMenu_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵtemplate(0, MtxGridColumnMenu_Case_0_Template, 3, 6, "button", 3)(1, MtxGridColumnMenu_Case_1_Template, 3, 6, "button", 4)(2, MtxGridColumnMenu_Case_2_Template, 3, 6, "button", 5)(3, MtxGridColumnMenu_Case_3_Template, 2, 5, "button", 6)(4, MtxGridColumnMenu_Case_4_Template, 3, 6, "button", 7)(5, MtxGridColumnMenu_Case_5_Template, 3, 6, "button", 8)(6, MtxGridColumnMenu_Case_6_Template, 3, 6, "button", 9);
          ɵɵelementStart(7, "mat-menu", 10, 0)(9, "div", 11);
          ɵɵlistener("click", function MtxGridColumnMenu_Template_div_click_9_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView($event.stopPropagation());
          })("keydown", function MtxGridColumnMenu_Template_div_keydown_9_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView($event.stopPropagation());
          });
          ɵɵtemplate(10, MtxGridColumnMenu_Conditional_10_Template, 3, 1, "div", 12);
          ɵɵelementStart(11, "div", 13);
          ɵɵtemplate(12, MtxGridColumnMenu_Conditional_12_Template, 3, 0, "div", 14)(13, MtxGridColumnMenu_Conditional_13_Template, 3, 0, "div", 15);
          ɵɵelementEnd();
          ɵɵtemplate(14, MtxGridColumnMenu_Conditional_14_Template, 3, 1, "div", 16);
          ɵɵelementEnd()();
          ɵɵtemplate(15, MtxGridColumnMenu_ng_template_15_Template, 3, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          let tmp_2_0;
          ɵɵconditional((tmp_2_0 = ctx.buttonType) === "raised" ? 0 : tmp_2_0 === "stroked" ? 1 : tmp_2_0 === "flat" ? 2 : tmp_2_0 === "icon" ? 3 : tmp_2_0 === "fab" ? 4 : tmp_2_0 === "mini-fab" ? 5 : 6);
          ɵɵadvance(10);
          ɵɵconditional(ctx.showHeader ? 10 : -1);
          ɵɵadvance(2);
          ɵɵconditional(ctx.sortable ? 12 : -1);
          ɵɵadvance();
          ɵɵconditional(!ctx.sortable ? 13 : -1);
          ɵɵadvance();
          ɵɵconditional(ctx.showFooter ? 14 : -1);
        }
      },
      dependencies: [AsyncPipe, NgTemplateOutlet, FormsModule, NgControlStatus, NgModel, MatButton, MatIconButton, MatFabButton, MatMiniFabButton, MatIcon, MatMenu, MatMenuTrigger, MatMenuItem, MatCheckbox, CdkDrag, CdkDropList, MtxToObservablePipe],
      styles: [".mtx-grid-column-menu,.mtx-grid-column-pin-list{color:var(--mtx-grid-column-menu-text-color, var(--mat-app-on-surface-variant))}.mtx-grid-column-menu .mat-mdc-menu-content{padding:0}.mtx-grid-column-menu-body{max-height:65vh;padding:8px 16px;overflow:auto}.mtx-grid-column-menu-header,.mtx-grid-column-menu-footer{position:sticky;z-index:1;padding:8px 16px}.mtx-grid-column-menu-header{top:0;border-bottom:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-app-outline-variant))}.mtx-grid-column-menu-footer{bottom:0;border-top:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-app-outline-variant))}.mtx-grid-column-menu-list{display:block;max-width:100%}.mtx-grid-column-menu-list.cdk-drop-list-dragging .mtx-grid-column-menu-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-menu-item{display:flex;flex-direction:row;align-items:center}.mtx-grid-column-menu-item.cdk-drag-disabled .cdk-drag-handle{opacity:.35;cursor:no-drop}.mtx-grid-column-menu-item .cdk-drag-handle{cursor:move}.mtx-grid-column-menu-item.cdk-drag-preview{border-radius:4px;box-shadow:0 0 0 1px var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-column-menu-item.cdk-drag-placeholder{opacity:0}.mtx-grid-column-menu-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-pin-button.mat-mdc-icon-button .mat-mdc-button-touch-target{width:100%;height:100%}.mtx-grid-column-pin-option.mat-menu-item{display:flex;align-items:center;height:32px}.mtx-grid-column-pin-option-placeholder{display:inline-block;width:20px;height:20px;line-height:20px;vertical-align:middle}.mtx-grid-column-pin-option-text{padding:0 8px;vertical-align:middle}.mtx-grid-column-drag-handle-icon:hover{cursor:move}.mtx-grid-column-menu-item-label.mat-mdc-checkbox .mat-mdc-checkbox-touch-target{width:100%;height:100%}\n"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridColumnMenu, [{
    type: Component,
    args: [{
      selector: "mtx-grid-column-menu",
      exportAs: "mtxGridColumnMenu",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [AsyncPipe, NgTemplateOutlet, FormsModule, MatButton, MatIconButton, MatFabButton, MatMiniFabButton, MatIcon, MatMenu, MatMenuTrigger, MatMenuItem, MatCheckbox, CdkDrag, CdkDropList, MtxToObservablePipe],
      template: `@switch (buttonType) {
  @case ('raised') {
    <button [class]="buttonClass" mat-raised-button type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
      {{buttonText}}
    </button>
  }
  @case ('stroked') {
    <button [class]="buttonClass" mat-stroked-button type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
      {{buttonText}}
    </button>
  }
  @case ('flat') {
    <button [class]="buttonClass" mat-flat-button type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
      {{buttonText}}
    </button>
    }
  @case ('icon') {
    <button [class]="buttonClass" mat-icon-button type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
    </button>
  }
  @case ('fab') {
    <button [class]="buttonClass" mat-fab type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
      {{buttonText}}
    </button>
  }
  @case ('mini-fab') {
    <button [class]="buttonClass" mat-mini-fab type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
      {{buttonText}}
    </button>
  }
  @default {
    <button [class]="buttonClass" mat-button type="button" [color]="buttonColor"
      [matMenuTriggerFor]="menu">
      @if (buttonIcon) {
        <mat-icon>{{buttonIcon}}</mat-icon>
      }
      {{buttonText}}
    </button>
  }
}

<mat-menu #menu="matMenu" class="mtx-grid-column-menu">
  <div class="mtx-grid-column-menu-content"
    (click)="$event.stopPropagation()" (keydown)="$event.stopPropagation()">
    @if (showHeader) {
      <div class="mtx-grid-column-menu-header">
        @if (headerTemplate) {
          <ng-template [ngTemplateOutlet]="headerTemplate"></ng-template>
        } @else {
          {{headerText}}
        }
      </div>
    }

    <div class="mtx-grid-column-menu-body">
      @if (sortable) {
        <div class="mtx-grid-column-menu-list"
          cdkDropList (cdkDropListDropped)="_handleDroped($event)">
          @for (col of columns; track col) {
            <div class="mtx-grid-column-menu-item"
              cdkDrag [cdkDragDisabled]="selectableChecked === 'show'? !col.show : col.hide">
              <svg class="mtx-grid-icon mtx-grid-column-drag-handle-icon" viewBox="0 0 24 24"
                width="24px" height="24px" fill="currentColor" focusable="false">
                <path d="M7,19V17H9V19H7M11,19V17H13V19H11M15,19V17H17V19H15M7,15V13H9V15H7M11,15V13H13V15H11M15,15V13H17V15H15M7,11V9H9V11H7M11,11V9H13V11H11M15,11V9H17V11H15M7,7V5H9V7H7M11,7V5H13V7H11M15,7V5H17V7H15Z" />
              </svg>
              <ng-template [ngTemplateOutlet]="checkboxList"
                [ngTemplateOutletContext]="{ $implicit: col }">
              </ng-template>
            </div>
          }
        </div>
      }

      @if (!sortable) {
        <div class="mtx-grid-column-menu-list">
          @for (col of columns; track col) {
            <div class="mtx-grid-column-menu-item">
              <ng-template [ngTemplateOutlet]="checkboxList"
                [ngTemplateOutletContext]="{ $implicit: col }">
              </ng-template>
            </div>
          }
        </div>
      }
    </div>

    @if (showFooter) {
      <div class="mtx-grid-column-menu-footer">
        @if (footerTemplate) {
          <ng-template [ngTemplateOutlet]="footerTemplate"></ng-template>
        } @else {
          {{footerText}}
        }
      </div>
    }
  </div>
</mat-menu>

<ng-template #checkboxList let-col>
  @if (pinnable) {
    <button class="mtx-grid-column-pin-button" mat-icon-button type="button"
      [matMenuTriggerFor]="pinList">
      @if (col.pinned) {
        <svg class="mtx-grid-icon mtx-grid-column-pin-icon"
          viewBox="0 0 24 24" width="24px" height="24px" fill="currentColor" focusable="false">
          <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z" />
        </svg>
      }
      @if (!col.pinned) {
        <svg class="mtx-grid-icon mtx-grid-column-pin-off-icon"
          viewBox="0 0 24 24" width="24px" height="24px" fill="currentColor" focusable="false">
          <path d="M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z" />
        </svg>
      }
      </button>
      <mat-menu #pinList="matMenu" class="mtx-grid-column-pin-list">
        @for (item of pinOptions; track item) {
          <button class="mtx-grid-column-pin-option" type="button"
            mat-menu-item
            (click)="_handlePinSelect(col, item.value)">
            <span class="mtx-grid-column-pin-option-placeholder">
              <!-- eslint-disable-next-line @angular-eslint/template/eqeqeq -->
              @if (col.pinned==item.value) {
                <svg class="mtx-grid-icon mtx-grid-column-pin-check-icon"
                  viewBox="0 0 24 24" width="24px" height="24px" fill="currentColor" focusable="false">
                  <path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" />
                </svg>
              }
            </span>
            <span class="mtx-grid-column-pin-option-text">{{item.label | toObservable | async}}</span>
          </button>
        }
      </mat-menu>
  }

  @if (selectable) {
    <mat-checkbox class="mtx-grid-column-menu-item-label"
      [(ngModel)]="col[selectableChecked]" [disabled]="col.disabled"
      (change)="_handleChecked(col)">{{col.header | toObservable | async}}</mat-checkbox>
  } @else {
    <span class="mtx-grid-column-menu-item-label">{{col.header | toObservable | async}}</span>
  }
</ng-template>
`,
      styles: [".mtx-grid-column-menu,.mtx-grid-column-pin-list{color:var(--mtx-grid-column-menu-text-color, var(--mat-app-on-surface-variant))}.mtx-grid-column-menu .mat-mdc-menu-content{padding:0}.mtx-grid-column-menu-body{max-height:65vh;padding:8px 16px;overflow:auto}.mtx-grid-column-menu-header,.mtx-grid-column-menu-footer{position:sticky;z-index:1;padding:8px 16px}.mtx-grid-column-menu-header{top:0;border-bottom:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-app-outline-variant))}.mtx-grid-column-menu-footer{bottom:0;border-top:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-app-outline-variant))}.mtx-grid-column-menu-list{display:block;max-width:100%}.mtx-grid-column-menu-list.cdk-drop-list-dragging .mtx-grid-column-menu-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-menu-item{display:flex;flex-direction:row;align-items:center}.mtx-grid-column-menu-item.cdk-drag-disabled .cdk-drag-handle{opacity:.35;cursor:no-drop}.mtx-grid-column-menu-item .cdk-drag-handle{cursor:move}.mtx-grid-column-menu-item.cdk-drag-preview{border-radius:4px;box-shadow:0 0 0 1px var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-column-menu-item.cdk-drag-placeholder{opacity:0}.mtx-grid-column-menu-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-pin-button.mat-mdc-icon-button .mat-mdc-button-touch-target{width:100%;height:100%}.mtx-grid-column-pin-option.mat-menu-item{display:flex;align-items:center;height:32px}.mtx-grid-column-pin-option-placeholder{display:inline-block;width:20px;height:20px;line-height:20px;vertical-align:middle}.mtx-grid-column-pin-option-text{padding:0 8px;vertical-align:middle}.mtx-grid-column-drag-handle-icon:hover{cursor:move}.mtx-grid-column-menu-item-label.mat-mdc-checkbox .mat-mdc-checkbox-touch-target{width:100%;height:100%}\n"]
    }]
  }], null, {
    menuPanel: [{
      type: ViewChild,
      args: ["menu", {
        static: true
      }]
    }],
    menuTrigger: [{
      type: ViewChild,
      args: [MatMenuTrigger]
    }],
    columns: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    selectableChecked: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    pinnable: [{
      type: Input
    }],
    buttonText: [{
      type: Input
    }],
    buttonType: [{
      type: Input
    }],
    buttonColor: [{
      type: Input
    }],
    buttonClass: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    showHeader: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    footerText: [{
      type: Input
    }],
    footerTemplate: [{
      type: Input
    }],
    columnChange: [{
      type: Output
    }],
    pinOptions: [{
      type: Input
    }]
  });
})();
var MtxGridExpansionToggle = class _MtxGridExpansionToggle {
  get opened() {
    return this._opened;
  }
  set opened(newValue) {
    this._opened = newValue;
    this.openedChange.emit(newValue);
  }
  get expanded() {
    return this._opened;
  }
  set expandableRow(value) {
    if (value !== this._row) {
      this._row = value;
    }
  }
  set template(value) {
    if (value !== this._tplRef) {
      this._tplRef = value;
    }
  }
  constructor() {
    this._opened = false;
    this.openedChange = new EventEmitter();
    this.toggleChange = new EventEmitter();
  }
  onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    this.toggle();
  }
  toggle() {
    this.opened = !this.opened;
    this.toggleChange.emit(this);
  }
  static {
    this.ɵfac = function MtxGridExpansionToggle_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridExpansionToggle)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MtxGridExpansionToggle,
      selectors: [["", "mtx-grid-expansion-toggle", ""]],
      hostVars: 2,
      hostBindings: function MtxGridExpansionToggle_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function MtxGridExpansionToggle_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
        if (rf & 2) {
          ɵɵclassProp("expanded", ctx.expanded);
        }
      },
      inputs: {
        opened: "opened",
        expandableRow: "expandableRow",
        template: [0, "expansionRowTpl", "template"]
      },
      outputs: {
        openedChange: "openedChange",
        toggleChange: "toggleChange"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridExpansionToggle, [{
    type: Directive,
    args: [{
      selector: "[mtx-grid-expansion-toggle]",
      standalone: true
    }]
  }], () => [], {
    opened: [{
      type: Input
    }],
    openedChange: [{
      type: Output
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.expanded"]
    }],
    expandableRow: [{
      type: Input
    }],
    template: [{
      type: Input,
      args: ["expansionRowTpl"]
    }],
    toggleChange: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var MtxGridSelectableCell = class _MtxGridSelectableCell {
  constructor() {
    this.ctrlKeyPressed = false;
    this.shiftKeyPressed = false;
    this._selected = false;
    this.cellSelectable = true;
    this.cellSelectedChange = new EventEmitter();
  }
  get selected() {
    return this._selected;
  }
  onClick(event) {
    this.ctrlKeyPressed = event.ctrlKey;
    this.shiftKeyPressed = event.shiftKey;
    if (this.cellSelectable) {
      this.select();
    }
  }
  select() {
    this._selected = true;
    this.cellSelectedChange.emit(this);
  }
  deselect() {
    this._selected = false;
    this.cellSelectedChange.emit(this);
  }
  toggle() {
    this._selected = !this._selected;
    this.cellSelectedChange.emit(this);
  }
  static {
    this.ɵfac = function MtxGridSelectableCell_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridSelectableCell)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MtxGridSelectableCell,
      selectors: [["", "mtx-grid-selectable-cell", ""]],
      hostVars: 2,
      hostBindings: function MtxGridSelectableCell_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function MtxGridSelectableCell_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
        if (rf & 2) {
          ɵɵclassProp("selected", ctx.selected);
        }
      },
      inputs: {
        cellSelectable: "cellSelectable"
      },
      outputs: {
        cellSelectedChange: "cellSelectedChange"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridSelectableCell, [{
    type: Directive,
    args: [{
      selector: "[mtx-grid-selectable-cell]",
      standalone: true
    }]
  }], null, {
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    cellSelectable: [{
      type: Input
    }],
    cellSelectedChange: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var MTX_GRID_DEFAULT_OPTIONS = new InjectionToken("mtx-grid-default-options");
var MtxGrid = class _MtxGrid {
  get _hasNoResult() {
    return (!this.dataSource.data || this.dataSource.data.length === 0) && !this.loading;
  }
  // TODO: Summary display conditions
  get _whetherShowSummary() {
    return this.showSummary;
  }
  constructor(_utils, _changeDetectorRef, _defaultOptions) {
    this._utils = _utils;
    this._changeDetectorRef = _changeDetectorRef;
    this._defaultOptions = _defaultOptions;
    this.dataSource = new MatTableDataSource();
    this.displayedColumns = [];
    this.columns = [];
    this.data = [];
    this.length = 0;
    this.loading = false;
    this.columnResizable = this._defaultOptions?.columnResizable ?? false;
    this.emptyValuePlaceholder = this._defaultOptions?.emptyValuePlaceholder ?? "--";
    this.pageOnFront = this._defaultOptions?.pageOnFront ?? true;
    this.showPaginator = this._defaultOptions?.showPaginator ?? true;
    this.pageDisabled = this._defaultOptions?.pageDisabled ?? false;
    this.showFirstLastButtons = this._defaultOptions?.showFirstLastButtons ?? true;
    this.pageIndex = this._defaultOptions?.pageIndex ?? 0;
    this.pageSize = this._defaultOptions?.pageSize ?? 10;
    this.pageSizeOptions = this._defaultOptions?.pageSizeOptions ?? [10, 50, 100];
    this.hidePageSize = this._defaultOptions?.hidePageSize ?? false;
    this.page = new EventEmitter();
    this.sortOnFront = this._defaultOptions?.sortOnFront ?? true;
    this.sortActive = this._defaultOptions?.sortActive ?? "";
    this.sortDirection = this._defaultOptions?.sortDirection ?? "";
    this.sortDisableClear = this._defaultOptions?.sortDisableClear ?? false;
    this.sortDisabled = this._defaultOptions?.sortDisabled ?? false;
    this.sortStart = this._defaultOptions?.sortStart ?? "asc";
    this.sortChange = new EventEmitter();
    this.rowHover = this._defaultOptions?.rowHover ?? false;
    this.rowStriped = this._defaultOptions?.rowStriped ?? false;
    this.rowClick = new EventEmitter();
    this.rowContextMenu = new EventEmitter();
    this.expansionRowStates = [];
    this.expandable = false;
    this.expansionChange = new EventEmitter();
    this.rowSelection = new SelectionModel(true, []);
    this.multiSelectable = this._defaultOptions?.multiSelectable ?? true;
    this.multiSelectionWithClick = this._defaultOptions?.multiSelectionWithClick ?? false;
    this.rowSelectable = this._defaultOptions?.rowSelectable ?? false;
    this.hideRowSelectionCheckbox = this._defaultOptions?.hideRowSelectionCheckbox ?? false;
    this.disableRowClickSelection = this._defaultOptions?.disableRowClickSelection ?? false;
    this.rowSelectionFormatter = {};
    this.rowSelected = [];
    this.rowSelectedChange = new EventEmitter();
    this.cellSelection = [];
    this.cellSelectable = this._defaultOptions?.cellSelectable ?? true;
    this.cellSelectedChange = new EventEmitter();
    this.showToolbar = this._defaultOptions?.showToolbar ?? false;
    this.toolbarTitle = this._defaultOptions?.toolbarTitle ?? "";
    this.columnHideable = this._defaultOptions?.columnHideable ?? true;
    this.columnHideableChecked = this._defaultOptions?.columnHideableChecked ?? "show";
    this.columnSortable = this._defaultOptions?.columnSortable ?? true;
    this.columnPinnable = this._defaultOptions?.columnPinnable ?? true;
    this.columnChange = new EventEmitter();
    this.columnPinOptions = this._defaultOptions?.columnPinOptions ?? [];
    this.showColumnMenuButton = this._defaultOptions?.showColumnMenuButton ?? true;
    this.columnMenuButtonText = this._defaultOptions?.columnMenuButtonText ?? "";
    this.columnMenuButtonType = this._defaultOptions?.columnMenuButtonType ?? "stroked";
    this.columnMenuButtonColor = this._defaultOptions?.columnMenuButtonColor;
    this.columnMenuButtonClass = this._defaultOptions?.columnMenuButtonClass ?? "";
    this.columnMenuButtonIcon = this._defaultOptions?.columnMenuButtonIcon ?? "";
    this.showColumnMenuHeader = this._defaultOptions?.showColumnMenuHeader ?? false;
    this.columnMenuHeaderText = this._defaultOptions?.columnMenuHeaderText ?? "Columns Header";
    this.showColumnMenuFooter = this._defaultOptions?.showColumnMenuFooter ?? false;
    this.columnMenuFooterText = this._defaultOptions?.columnMenuFooterText ?? "Columns Footer";
    this.noResultText = this._defaultOptions?.noResultText ?? "No records found";
    this.useContentRowTemplate = false;
    this.useContentHeaderRowTemplate = false;
    this.useContentFooterRowTemplate = false;
    this.showSummary = false;
    this.showSidebar = false;
    this.showStatusbar = false;
  }
  detectChanges() {
    this._changeDetectorRef.detectChanges();
  }
  _getColData(data, colDef) {
    return this._utils.getColData(data, colDef);
  }
  _isColumnHide(item) {
    return item.hide !== void 0 ? item.hide : item.show !== void 0 ? !item.show : false;
  }
  // Waiting for async data
  ngOnChanges(changes) {
    this._countPinnedPosition();
    this.displayedColumns = this.columns.filter((item) => !this._isColumnHide(item)).map((item) => item.field);
    if (this.showColumnMenuButton) {
      this.columns.forEach((item) => {
        item.hide = this._isColumnHide(item);
        item.show = !item.hide;
      });
    }
    if (this.rowSelectable && !this.hideRowSelectionCheckbox) {
      this.displayedColumns.unshift("MtxGridCheckboxColumnDef");
    }
    if (this.expandable) {
      this.expansionRowStates = [];
      this.data?.forEach((_) => {
        this.expansionRowStates.push({
          expanded: false
        });
      });
    }
    if (this.rowSelectable) {
      this.rowSelection = new SelectionModel(this.multiSelectable, this.rowSelected);
    }
    this.dataSource = new MatTableDataSource(this.data);
    this.dataSource.paginator = this.pageOnFront ? this.paginator : null;
    this.dataSource.sort = this.sortOnFront ? this.sort : null;
    if (changes.data) {
      this.scrollTop(0);
    }
  }
  ngAfterViewInit() {
    if (this.pageOnFront) {
      this.dataSource.paginator = this.paginator;
    }
    if (this.sortOnFront) {
      this.dataSource.sort = this.sort;
    }
    if (this.rowDefs?.length > 0 && this.useContentRowTemplate) {
      this.rowDefs.forEach((rowDef) => this.table.addRowDef(rowDef));
    }
    if (this.headerRowDefs?.length > 0 && this.useContentHeaderRowTemplate) {
      this.headerRowDefs.forEach((headerRowDef) => this.table.addHeaderRowDef(headerRowDef));
    }
    if (this.footerRowDefs?.length > 0 && this.useContentFooterRowTemplate) {
      this.footerRowDefs.forEach((footerRowDef) => this.table.addFooterRowDef(footerRowDef));
    }
  }
  ngOnDestroy() {
  }
  _countPinnedPosition() {
    const count = (acc, cur) => acc + parseFloat(cur.width || "80px");
    const pinnedLeftCols = this.columns.filter((col) => col.pinned && col.pinned === "left");
    pinnedLeftCols.forEach((item, idx) => {
      item.left = pinnedLeftCols.slice(0, idx).reduce(count, 0) + "px";
    });
    const pinnedRightCols = this.columns.filter((col) => col.pinned && col.pinned === "right").reverse();
    pinnedRightCols.forEach((item, idx) => {
      item.right = pinnedRightCols.slice(0, idx).reduce(count, 0) + "px";
    });
  }
  _getIndex(index, dataIndex) {
    return index === void 0 ? dataIndex : index;
  }
  _onSortChange(sort) {
    this.sortChange.emit(sort);
  }
  _onRowDataChange(record) {
    this.rowChangeRecord = record;
    this._changeDetectorRef.markForCheck();
  }
  /** Expansion change event */
  _onExpansionChange(expansionRef, rowData, column, index) {
    this.expansionChange.emit({
      expanded: expansionRef.expanded,
      data: rowData,
      index,
      column
    });
  }
  /** Cell select event */
  _selectCell(cellRef, rowData, colDef) {
    if (this._selectedCell !== cellRef) {
      const colValue = this._utils.getCellValue(rowData, colDef);
      this.cellSelection = [];
      this.cellSelection.push({
        cellData: colValue,
        rowData,
        colDef
      });
      this.cellSelectedChange.emit(this.cellSelection);
      if (this._selectedCell) {
        this._selectedCell.deselect();
      }
    }
    this._selectedCell = cellRef.selected ? cellRef : void 0;
  }
  /** Row select event */
  _selectRow(event, rowData, index) {
    if (this.rowSelectable && !this.rowSelectionFormatter.disabled?.(rowData, index) && !this.rowSelectionFormatter.hideCheckbox?.(rowData, index) && !this.disableRowClickSelection) {
      if (!this.multiSelectionWithClick && !event.ctrlKey && !event.metaKey) {
        this.rowSelection.clear();
      }
      this._toggleNormalCheckbox(rowData);
    }
    this.rowClick.emit({
      event,
      rowData,
      index
    });
  }
  /** Whether the number of selected elements matches the total number of rows. */
  _isAllSelected() {
    const numSelected = this.rowSelection.selected.length;
    const numRows = this.dataSource.data.filter((row, index) => !this.rowSelectionFormatter.disabled?.(row, index)).length;
    return numSelected === numRows;
  }
  /** Select all rows if they are not all selected; otherwise clear selection. */
  _toggleMasterCheckbox() {
    this._isAllSelected() ? this.rowSelection.clear() : this.dataSource.data.forEach((row, index) => {
      if (!this.rowSelectionFormatter.disabled?.(row, index)) {
        this.rowSelection.select(row);
      }
    });
    this.rowSelectedChange.emit(this.rowSelection.selected);
  }
  /** Select normal row */
  _toggleNormalCheckbox(row) {
    this.rowSelection.toggle(row);
    this.rowSelectedChange.emit(this.rowSelection.selected);
  }
  /** Column change event */
  _onColumnChange(columns) {
    this.columnChange.emit(columns);
    this.displayedColumns = Object.assign([], this.getDisplayedColumnFields(columns));
    if (this.rowSelectable && !this.hideRowSelectionCheckbox) {
      this.displayedColumns.unshift("MtxGridCheckboxColumnDef");
    }
  }
  getDisplayedColumnFields(columns) {
    const fields = columns.filter((item) => this.columnHideableChecked === "show" ? item.show : !item.hide).map((item) => item.field);
    return fields;
  }
  /** Customize expansion event */
  toggleExpansion(index) {
    if (!this.expandable) {
      throw new Error("The `expandable` should be set true.");
    }
    this.expansionRowStates[index].expanded = !this.expansionRowStates[index].expanded;
    return this.expansionRowStates[index].expanded;
  }
  /** Scroll to top when turn to the next page. */
  _onPage(e) {
    if (this.pageOnFront) {
      this.scrollTop(0);
    }
    this.page.emit(e);
  }
  scrollTop(value) {
    if (value == null) {
      return this.tableContainer?.nativeElement.scrollTop;
    }
    if (this.tableContainer && !this.loading) {
      this.tableContainer.nativeElement.scrollTop = value;
    }
  }
  scrollLeft(value) {
    if (value == null) {
      return this.tableContainer?.nativeElement.scrollLeft;
    }
    if (this.tableContainer && !this.loading) {
      this.tableContainer.nativeElement.scrollLeft = value;
    }
  }
  _contextmenu(event, rowData, index) {
    this.rowContextMenu.emit({
      event,
      rowData,
      index
    });
  }
  static {
    this.ɵfac = function MtxGrid_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGrid)(ɵɵdirectiveInject(MtxGridUtils), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MTX_GRID_DEFAULT_OPTIONS, 8));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MtxGrid,
      selectors: [["mtx-grid"]],
      contentQueries: function MtxGrid_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, MatRowDef, 4);
          ɵɵcontentQuery(dirIndex, MatHeaderRowDef, 4);
          ɵɵcontentQuery(dirIndex, MatFooterRow, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rowDefs = _t);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerRowDefs = _t);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerRowDefs = _t);
        }
      },
      viewQuery: function MtxGrid_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatTable, 5);
          ɵɵviewQuery(MatPaginator, 5);
          ɵɵviewQuery(MatSort, 5);
          ɵɵviewQuery(_c4, 5);
          ɵɵviewQuery(_c5, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.table = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.paginator = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sort = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenu = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableContainer = _t.first);
        }
      },
      hostAttrs: [1, "mtx-grid"],
      inputs: {
        displayedColumns: "displayedColumns",
        columns: "columns",
        data: "data",
        length: "length",
        loading: [2, "loading", "loading", booleanAttribute],
        trackBy: "trackBy",
        columnResizable: [2, "columnResizable", "columnResizable", booleanAttribute],
        emptyValuePlaceholder: "emptyValuePlaceholder",
        pageOnFront: [2, "pageOnFront", "pageOnFront", booleanAttribute],
        showPaginator: [2, "showPaginator", "showPaginator", booleanAttribute],
        pageDisabled: [2, "pageDisabled", "pageDisabled", booleanAttribute],
        showFirstLastButtons: [2, "showFirstLastButtons", "showFirstLastButtons", booleanAttribute],
        pageIndex: "pageIndex",
        pageSize: "pageSize",
        pageSizeOptions: "pageSizeOptions",
        hidePageSize: [2, "hidePageSize", "hidePageSize", booleanAttribute],
        paginationTemplate: "paginationTemplate",
        sortOnFront: [2, "sortOnFront", "sortOnFront", booleanAttribute],
        sortActive: "sortActive",
        sortDirection: "sortDirection",
        sortDisableClear: [2, "sortDisableClear", "sortDisableClear", booleanAttribute],
        sortDisabled: [2, "sortDisabled", "sortDisabled", booleanAttribute],
        sortStart: "sortStart",
        rowHover: [2, "rowHover", "rowHover", booleanAttribute],
        rowStriped: [2, "rowStriped", "rowStriped", booleanAttribute],
        expandable: [2, "expandable", "expandable", booleanAttribute],
        expansionTemplate: "expansionTemplate",
        multiSelectable: [2, "multiSelectable", "multiSelectable", booleanAttribute],
        multiSelectionWithClick: [2, "multiSelectionWithClick", "multiSelectionWithClick", booleanAttribute],
        rowSelectable: [2, "rowSelectable", "rowSelectable", booleanAttribute],
        hideRowSelectionCheckbox: [2, "hideRowSelectionCheckbox", "hideRowSelectionCheckbox", booleanAttribute],
        disableRowClickSelection: [2, "disableRowClickSelection", "disableRowClickSelection", booleanAttribute],
        rowSelectionFormatter: "rowSelectionFormatter",
        rowClassFormatter: "rowClassFormatter",
        rowSelected: "rowSelected",
        cellSelectable: [2, "cellSelectable", "cellSelectable", booleanAttribute],
        showToolbar: [2, "showToolbar", "showToolbar", booleanAttribute],
        toolbarTitle: "toolbarTitle",
        toolbarTemplate: "toolbarTemplate",
        columnHideable: [2, "columnHideable", "columnHideable", booleanAttribute],
        columnHideableChecked: "columnHideableChecked",
        columnSortable: [2, "columnSortable", "columnSortable", booleanAttribute],
        columnPinnable: [2, "columnPinnable", "columnPinnable", booleanAttribute],
        columnPinOptions: "columnPinOptions",
        showColumnMenuButton: [2, "showColumnMenuButton", "showColumnMenuButton", booleanAttribute],
        columnMenuButtonText: "columnMenuButtonText",
        columnMenuButtonType: "columnMenuButtonType",
        columnMenuButtonColor: "columnMenuButtonColor",
        columnMenuButtonClass: "columnMenuButtonClass",
        columnMenuButtonIcon: "columnMenuButtonIcon",
        showColumnMenuHeader: [2, "showColumnMenuHeader", "showColumnMenuHeader", booleanAttribute],
        columnMenuHeaderText: "columnMenuHeaderText",
        columnMenuHeaderTemplate: "columnMenuHeaderTemplate",
        showColumnMenuFooter: [2, "showColumnMenuFooter", "showColumnMenuFooter", booleanAttribute],
        columnMenuFooterText: "columnMenuFooterText",
        columnMenuFooterTemplate: "columnMenuFooterTemplate",
        noResultText: "noResultText",
        noResultTemplate: "noResultTemplate",
        headerTemplate: "headerTemplate",
        headerExtraTemplate: "headerExtraTemplate",
        cellTemplate: "cellTemplate",
        useContentRowTemplate: [2, "useContentRowTemplate", "useContentRowTemplate", booleanAttribute],
        useContentHeaderRowTemplate: [2, "useContentHeaderRowTemplate", "useContentHeaderRowTemplate", booleanAttribute],
        useContentFooterRowTemplate: [2, "useContentFooterRowTemplate", "useContentFooterRowTemplate", booleanAttribute],
        showSummary: [2, "showSummary", "showSummary", booleanAttribute],
        summaryTemplate: "summaryTemplate",
        showSidebar: [2, "showSidebar", "showSidebar", booleanAttribute],
        sidebarTemplate: "sidebarTemplate",
        showStatusbar: [2, "showStatusbar", "showStatusbar", booleanAttribute],
        statusbarTemplate: "statusbarTemplate"
      },
      outputs: {
        page: "page",
        sortChange: "sortChange",
        rowClick: "rowClick",
        rowContextMenu: "rowContextMenu",
        expansionChange: "expansionChange",
        rowSelectedChange: "rowSelectedChange",
        cellSelectedChange: "cellSelectedChange",
        columnChange: "columnChange"
      },
      exportAs: ["mtxGrid"],
      standalone: true,
      features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 17,
      vars: 9,
      consts: [["tableContainer", ""], ["headerExtraTplBase", ""], ["columnMenu", ""], [1, "mtx-grid-progress"], [1, "mtx-grid-toolbar"], [1, "mtx-grid-main", "mtx-grid-layout"], [1, "mtx-grid-content", "mtx-grid-layout"], [1, "mat-table-container"], ["mat-table", "", "matSort", "", 3, "class", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], ["mat-table", "", "columnResize", "", "matSort", "", 3, "class", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], [1, "mtx-grid-no-result"], [1, "mtx-grid-sidebar"], [1, "mtx-grid-footer"], [1, "mtx-grid-statusbar"], [1, "mtx-grid-pagination"], [3, "ngTemplateOutlet"], [3, "mat-paginator-hidden", "showFirstLastButtons", "length", "pageIndex", "pageSize", "pageSizeOptions", "hidePageSize", "disabled"], ["mode", "indeterminate"], [1, "mtx-grid-toolbar-content"], [1, "mtx-grid-toolbar-actions"], [3, "columns", "buttonText", "buttonType", "buttonColor", "buttonClass", "buttonIcon", "selectable", "selectableChecked", "sortable", "pinnable", "showHeader", "headerText", "headerTemplate", "showFooter", "footerText", "footerTemplate", "pinOptions"], [1, "mtx-grid-toolbar-title"], [3, "columnChange", "columns", "buttonText", "buttonType", "buttonColor", "buttonClass", "buttonIcon", "selectable", "selectableChecked", "sortable", "pinnable", "showHeader", "headerText", "headerTemplate", "showFooter", "footerText", "footerTemplate", "pinOptions"], ["mat-table", "", "matSort", "", 3, "matSortChange", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], ["matColumnDef", "MtxGridCheckboxColumnDef"], [3, "matColumnDef", "sticky", "stickyEnd"], ["mat-header-row", ""], ["mat-row", "", 3, "class", "selected"], ["mat-footer-row", ""], ["mat-header-cell", "", "class", "mtx-grid-checkbox-cell", 4, "matHeaderCellDef"], ["mat-cell", "", "class", "mtx-grid-checkbox-cell", 4, "matCellDef"], ["mat-footer-cell", "", "class", "mtx-grid-checkbox-cell", 4, "matFooterCellDef"], ["mat-header-cell", "", 1, "mtx-grid-checkbox-cell"], [3, "checked", "indeterminate"], [3, "change", "checked", "indeterminate"], ["mat-cell", "", 1, "mtx-grid-checkbox-cell"], [3, "disabled", "checked"], [3, "click", "change", "disabled", "checked"], ["mat-footer-cell", "", 1, "mtx-grid-checkbox-cell"], ["mat-header-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "style", 4, "matHeaderCellDef"], ["mat-cell", "", "mtx-grid-selectable-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "style", "cellSelectable", "cellSelectedChange", 4, "matCellDef"], ["mat-footer-cell", "", 3, "mat-table-sticky-left", "mat-table-sticky-right", "style", 4, "matFooterCellDef"], ["mat-header-cell", ""], [1, "mat-header-cell-inner"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "mat-sort-header", "disabled", "disableClear", "arrowPosition", "start"], [1, "mtx-grid-expansion-placeholder"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mat-sort-header-icon"], ["d", "M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z"], ["mat-cell", "", "mtx-grid-selectable-cell", "", 3, "cellSelectedChange", "cellSelectable"], [3, "rowData", "colDef", "placeholder"], ["mat-icon-button", "", "mtx-grid-expansion-toggle", "", "type", "button", 1, "mtx-grid-row-expand-button", 3, "opened"], [3, "rowDataChange", "rowData", "colDef", "placeholder"], ["mat-icon-button", "", "mtx-grid-expansion-toggle", "", "type", "button", 1, "mtx-grid-row-expand-button", 3, "openedChange", "toggleChange", "opened"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-row-expand-icon"], ["d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"], ["mat-footer-cell", ""], [3, "summary", "data", "colDef", "placeholder"], ["mat-header-row", "", 4, "matHeaderRowDef", "matHeaderRowDefSticky"], ["mat-row", "", 3, "class", "selected", "click", "contextmenu", 4, "matRowDef", "matRowDefColumns"], ["mat-row", "", 3, "click", "contextmenu"], ["mat-footer-row", "", 4, "matFooterRowDef", "matFooterRowDefSticky"], ["matColumnDef", "MtxGridExpansionColumnDef"], ["mat-cell", "", 4, "matCellDef"], ["mat-row", "", "class", "mtx-grid-expansion", 3, "class", 4, "matRowDef", "matRowDefColumns"], ["mat-cell", ""], [1, "mtx-grid-expansion-detail"], ["mat-row", "", 1, "mtx-grid-expansion"], ["mat-table", "", "columnResize", "", "matSort", "", 3, "matSortChange", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], ["mat-header-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "style", "resizable", "matResizableMinWidthPx", "matResizableMaxWidthPx", 4, "matHeaderCellDef"], ["mat-header-cell", "", 3, "resizable", "matResizableMinWidthPx", "matResizableMaxWidthPx"], [3, "page", "showFirstLastButtons", "length", "pageIndex", "pageSize", "pageSizeOptions", "hidePageSize", "disabled"]],
      template: function MtxGrid_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, MtxGrid_Conditional_0_Template, 2, 0, "div", 3)(1, MtxGrid_Conditional_1_Template, 6, 2, "div", 4);
          ɵɵelementStart(2, "div", 5)(3, "div", 6)(4, "div", 7, 0);
          ɵɵtemplate(6, MtxGrid_Conditional_6_Template, 8, 19, "table", 8)(7, MtxGrid_Conditional_7_Template, 8, 19, "table", 9);
          ɵɵelementEnd();
          ɵɵtemplate(8, MtxGrid_Conditional_8_Template, 3, 1, "div", 10);
          ɵɵelementEnd();
          ɵɵtemplate(9, MtxGrid_Conditional_9_Template, 2, 1, "div", 11);
          ɵɵelementEnd();
          ɵɵelementStart(10, "div", 12);
          ɵɵtemplate(11, MtxGrid_Conditional_11_Template, 2, 1, "div", 13);
          ɵɵelementStart(12, "div", 14);
          ɵɵtemplate(13, MtxGrid_Conditional_13_Template, 1, 1, null, 15)(14, MtxGrid_Conditional_14_Template, 1, 9, "mat-paginator", 16);
          ɵɵelementEnd()();
          ɵɵtemplate(15, MtxGrid_ng_template_15_Template, 3, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          ɵɵconditional(ctx.loading ? 0 : -1);
          ɵɵadvance();
          ɵɵconditional(ctx.showToolbar ? 1 : -1);
          ɵɵadvance(3);
          ɵɵclassProp("mat-table-with-data", !ctx._hasNoResult);
          ɵɵadvance(2);
          ɵɵconditional(!ctx.columnResizable ? 6 : 7);
          ɵɵadvance(2);
          ɵɵconditional(ctx._hasNoResult ? 8 : -1);
          ɵɵadvance();
          ɵɵconditional(ctx.showSidebar ? 9 : -1);
          ɵɵadvance(2);
          ɵɵconditional(ctx.showStatusbar ? 11 : -1);
          ɵɵadvance(2);
          ɵɵconditional(ctx.paginationTemplate ? 13 : 14);
        }
      },
      dependencies: [AsyncPipe, NgTemplateOutlet, MatProgressBar, MatIconButton, MatCheckbox, MatTable, MatColumnDef, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatSort, MatSortHeader, MatPaginator, MatResizable, MatColumnResize, MtxGridCell, MtxGridColumnMenu, MtxGridSelectableCell, MtxGridExpansionToggle, MtxIsTemplateRefPipe, MtxGridColClassPipe, MtxGridRowClassPipe, MtxToObservablePipe],
      styles: [".mtx-grid{position:relative;display:flex;flex-direction:column;width:100%;overflow:hidden;border:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant));border-radius:var(--mtx-grid-container-shape, var(--mat-app-corner-medium))}.mtx-grid .mat-mdc-table{--mat-table-row-item-outline-color: var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid .mat-mdc-table.mat-table-striped .mat-row-odd{background-color:var(--mtx-grid-table-row-striped-background-color, var(--mat-app-surface-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row:hover{background-color:var(--mtx-grid-table-row-hover-background-color, var(--mat-app-secondary-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row.selected:hover{background-color:var(--mtx-grid-table-row-selected-hover-background-color, var(--mat-app-primary-container))}.mtx-grid .mat-mdc-table .mat-mdc-row.selected{background-color:var(--mtx-grid-table-row-selected-background-color, var(--mat-app-secondary-container))}.mtx-grid .mat-mdc-table .mat-mdc-cell.selected{box-shadow:inset 0 0 0 1px var(--mtx-grid-table-cell-selected-outline-color, var(--mat-app-primary))}.mtx-grid .mat-table-container{overflow:auto}.mtx-grid .mat-table-container.mat-table-with-data{flex:1}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table){min-width:100%;border-collapse:separate}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-header-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-footer-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-cell:not(.mtx-grid-checkbox-cell){min-width:var(--mtx-grid-table-cell-min-width)}.mtx-grid .mat-table-sticky-left{border-right:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-left{border-right-width:0;border-left:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-table-sticky-right{border-left:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-right{border-left-width:0;border-right:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-mdc-footer-cell{border-top:1px solid var(--mat-table-row-item-outline-color);background-color:var(--mtx-grid-table-footer-background-color, var(--mat-app-surface-container))}.mtx-grid .mat-mdc-row.mtx-grid-expansion{height:0;overflow:hidden}.mtx-grid .mat-mdc-row.mtx-grid-expansion .mat-mdc-cell{padding-top:0;padding-bottom:0}.mtx-grid .mat-mdc-row.mtx-grid-expansion.collapsed .mat-mdc-cell{border-bottom-width:0}.mtx-grid .mat-sort-header-icon{margin:0 4px}.mtx-grid .mat-header-cell-inner{display:inline-flex;align-items:center;vertical-align:middle}.mtx-grid .mat-mdc-paginator{border-top:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant));border-bottom-left-radius:var(--mtx-grid-container-shape, var(--mat-app-corner-medium));border-bottom-right-radius:var(--mtx-grid-container-shape, var(--mat-app-corner-medium))}.mtx-grid .mat-paginator-hidden{display:none}.mtx-grid .mtx-grid-checkbox-cell{width:60px;min-width:60px;padding:0 calc((60px - var(--mdc-checkbox-state-layer-size)) / 2)}.mtx-grid-progress{position:absolute;top:0;z-index:120;width:100%}.mtx-grid-toolbar{display:flex;justify-content:space-between;align-items:center;min-height:var(--mat-table-header-container-height);padding:8px;box-sizing:border-box;border-bottom:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-toolbar-content{flex:1;width:0;padding:0 8px}.mtx-grid-layout{display:flex;flex:1 1 auto;overflow:auto}.mtx-grid-content{flex-direction:column;width:0}.mtx-grid-sidebar{max-width:50%;border-left:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}[dir=rtl] .mtx-grid-sidebar{border-left-width:0;border-right:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-footer{position:relative;z-index:1}.mtx-grid-statusbar{display:flex;align-items:center;min-height:var(--mat-table-header-container-height);padding:8px;box-sizing:border-box;border-top:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-no-result{display:flex;justify-content:center;align-items:center;flex:1;min-height:150px}.mtx-grid-expansion-placeholder{display:inline-block;vertical-align:middle;width:var(--mdc-icon-button-state-layer-size, var(var(--mtx-grid-row-expand-button-size)));height:var(--mdc-icon-button-state-layer-size, var(var(--mtx-grid-row-expand-button-size)))}.mtx-grid-expansion-detail{display:flex;align-items:center;min-height:var(--mat-table-row-item-container-height);overflow:hidden}.mtx-grid-row-expand-button.expanded .mtx-grid-row-expand-icon{transform:rotate(90deg)}.mtx-grid-row-expand-button.mat-mdc-icon-button,.mtx-grid-row-expand-button+mtx-grid-cell{vertical-align:middle}.mtx-grid-icon{width:20px;height:20px;font-size:20px}\n"],
      encapsulation: 2,
      data: {
        animation: [trigger("expansion", [state("collapsed, void", style({
          height: "0",
          minHeight: "0",
          visibility: "hidden"
        })), state("expanded", style({
          height: "*",
          visibility: "visible"
        })), transition("expanded <=> collapsed", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)")), transition("expanded <=> void", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGrid, [{
    type: Component,
    args: [{
      selector: "mtx-grid",
      exportAs: "mtxGrid",
      host: {
        class: "mtx-grid"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("expansion", [state("collapsed, void", style({
        height: "0",
        minHeight: "0",
        visibility: "hidden"
      })), state("expanded", style({
        height: "*",
        visibility: "visible"
      })), transition("expanded <=> collapsed", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)")), transition("expanded <=> void", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])],
      standalone: true,
      imports: [AsyncPipe, NgTemplateOutlet, MatProgressBar, MatIconButton, MatCheckbox, MatTable, MatColumnDef, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatSort, MatSortHeader, MatPaginator, MatResizable, MatColumnResize, MtxGridCell, MtxGridColumnMenu, MtxGridSelectableCell, MtxGridExpansionToggle, MtxIsTemplateRefPipe, MtxGridColClassPipe, MtxGridRowClassPipe, MtxToObservablePipe],
      template: `<!-- Progress bar-->
@if (loading) {
  <div class="mtx-grid-progress">
    <mat-progress-bar mode="indeterminate"></mat-progress-bar>
  </div>
}

<!-- Toolbar -->
@if (showToolbar) {
  <div class="mtx-grid-toolbar">
    <div class="mtx-grid-toolbar-content">
      @if (toolbarTemplate) {
        <ng-template [ngTemplateOutlet]="toolbarTemplate"></ng-template>
      } @else {
        @if (toolbarTitle) {
          <div class="mtx-grid-toolbar-title">{{toolbarTitle}}</div>
        }
      }
    </div>
    <div class="mtx-grid-toolbar-actions">
      @if (showColumnMenuButton) {
        <mtx-grid-column-menu #columnMenu
          [columns]="columns"
          [buttonText]="columnMenuButtonText"
          [buttonType]="columnMenuButtonType"
          [buttonColor]="columnMenuButtonColor"
          [buttonClass]="columnMenuButtonClass"
          [buttonIcon]="columnMenuButtonIcon"
          [selectable]="columnHideable"
          [selectableChecked]="columnHideableChecked"
          [sortable]="columnSortable"
          [pinnable]="columnPinnable"
          [showHeader]="showColumnMenuHeader"
          [headerText]="columnMenuHeaderText"
          [headerTemplate]="columnMenuHeaderTemplate"
          [showFooter]="showColumnMenuFooter"
          [footerText]="columnMenuFooterText"
          [footerTemplate]="columnMenuFooterTemplate"
          [pinOptions]="columnPinOptions"
          (columnChange)="_onColumnChange($event)">
        </mtx-grid-column-menu>
      }
    </div>
  </div>
}

<div class="mtx-grid-main mtx-grid-layout">
  <!-- Table content -->
  <div class="mtx-grid-content mtx-grid-layout">
    <div #tableContainer class="mat-table-container" [class.mat-table-with-data]="!_hasNoResult">
      @if (!columnResizable) {
        <table mat-table
          [class]="{'mat-table-hover': rowHover, 'mat-table-striped': rowStriped, 'mat-table-expandable': expandable}"
          [dataSource]="dataSource" [multiTemplateDataRows]="expandable"
          matSort
          [matSortActive]="sortActive"
          [matSortDirection]="sortDirection"
          [matSortDisableClear]="sortDisableClear"
          [matSortDisabled]="sortDisabled"
          [matSortStart]="sortStart"
          (matSortChange)="_onSortChange($event)"
          [trackBy]="trackBy">
          @if (rowSelectable && !hideRowSelectionCheckbox) {
            <ng-container matColumnDef="MtxGridCheckboxColumnDef">
              <th mat-header-cell *matHeaderCellDef class="mtx-grid-checkbox-cell">
                @if (multiSelectable) {
                  <mat-checkbox
                    [checked]="rowSelection.hasValue() && _isAllSelected()"
                    [indeterminate]="rowSelection.hasValue() && !_isAllSelected()"
                    (change)="$event ? _toggleMasterCheckbox() : null">
                  </mat-checkbox>
                }
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                class="mtx-grid-checkbox-cell">
                @if (!(rowSelectionFormatter.hideCheckbox && rowSelectionFormatter.hideCheckbox(row, _getIndex(index, dataIndex)))) {
                  <mat-checkbox
                    [disabled]="rowSelectionFormatter.disabled && rowSelectionFormatter.disabled(row, _getIndex(index, dataIndex))"
                    [checked]="rowSelection.isSelected(row)"
                    (click)="$event.stopPropagation()"
                    (change)="$event ? _toggleNormalCheckbox(row) : null">
                  </mat-checkbox>
                }
              </td>
              <td mat-footer-cell *matFooterCellDef class="mtx-grid-checkbox-cell"></td>
            </ng-container>
          }
          @for (col of columns; track col) {
            <ng-container [matColumnDef]="col.field"
              [sticky]="col.pinned==='left'" [stickyEnd]="col.pinned==='right'">
              <th mat-header-cell *matHeaderCellDef
                [class]="col | colClass"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style]="{'width': col.width, 'min-width': col.width, 'left': col.left, 'right': col.right}">
                <div class="mat-header-cell-inner">
                  @if (headerTemplate | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(headerTemplate)"
                      [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                    </ng-template>
                  } @else {
                    @if ($any(headerTemplate)?.[col.field] | isTemplateRef) {
                      <ng-template [ngTemplateOutlet]="$any(headerTemplate)[col.field]"
                        [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                      </ng-template>
                    } @else {
                      <div [mat-sort-header]="col.sortProp?.id || col.field"
                        [disabled]="!col.sortable"
                        [disableClear]="col.sortProp?.disableClear ?? sortDisableClear"
                        [arrowPosition]="col.sortProp?.arrowPosition!"
                        [start]="col.sortProp?.start!">
                        @if (col.showExpand) {
                          <span class="mtx-grid-expansion-placeholder"></span>
                        }
                        <span>{{col.header | toObservable | async}}</span>
                        @if (col.sortable) {
                          <svg class="mtx-grid-icon mat-sort-header-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z" />
                          </svg>
                        }
                      </div>
                      <ng-template [ngTemplateOutlet]="headerExtraTplBase"
                        [ngTemplateOutletContext]="{ $implicit: headerExtraTemplate, colDef: col }">
                      </ng-template>
                    }
                  }
                </div>
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                [class]="col | colClass: row: rowChangeRecord: rowChangeRecord?.currentValue"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style]="{'width': col.width, 'min-width': col.width, 'left': col.left, 'right': col.right}"
                mtx-grid-selectable-cell [cellSelectable]="cellSelectable"
                (cellSelectedChange)="_selectCell($event, row, col)">
                @if (cellTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(cellTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                  </ng-template>
                } @else {
                  @if ($any(cellTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(cellTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                    </ng-template>
                  } @else {
                    @if (col.cellTemplate) {
                      <ng-template
                        [ngTemplateOutlet]="col.cellTemplate!"
                        [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                      </ng-template>
                    } @else {
                      @if (col.showExpand) {
                        <button class="mtx-grid-row-expand-button"
                          mat-icon-button mtx-grid-expansion-toggle type="button"
                          [(opened)]="expansionRowStates[dataIndex].expanded"
                          (toggleChange)="_onExpansionChange($event, row, col, dataIndex);">
                          <svg class="mtx-grid-icon mtx-grid-row-expand-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
                          </svg>
                        </button>
                      }
                      <mtx-grid-cell [rowData]="row" [colDef]="col" [placeholder]="emptyValuePlaceholder"
                        (rowDataChange)="_onRowDataChange($event)"></mtx-grid-cell>
                    }
                  }
                }
              </td>
              <td mat-footer-cell *matFooterCellDef
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style]="{'width': col.width, 'min-width': col.width, 'left': col.left, 'right': col.right}">
                @if (col.showExpand) {
                  <span class="mtx-grid-expansion-placeholder"></span>
                }
                @if (summaryTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(summaryTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: col, colDef: col, data: data }">
                  </ng-template>
                } @else {
                  @if ($any(summaryTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(summaryTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: _getColData(data, col), colData: _getColData(data, col), colDef: col }">
                    </ng-template>
                  } @else {
                    <mtx-grid-cell [summary]="true" [data]="data" [colDef]="col"
                      [placeholder]="emptyValuePlaceholder"></mtx-grid-cell>
                  }
                }
              </td>
            </ng-container>
          }
          @if (!useContentHeaderRowTemplate) {
            <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (!useContentRowTemplate) {
            <tr mat-row
              *matRowDef="let row; let index = index; let dataIndex = dataIndex; columns: displayedColumns;"
              [class]="row | rowClass: index: dataIndex: rowClassFormatter"
              [class.selected]="rowSelection.isSelected(row)"
              (click)="_selectRow($event, row, _getIndex(index, dataIndex))"
              (contextmenu)="_contextmenu($event, row, _getIndex(index, dataIndex))">
            </tr>
          }
          @if (_whetherShowSummary) {
            <tr mat-footer-row *matFooterRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (expandable) {
            <!-- Expanded Content Column - The expandable row is made up of this one column that spans across all columns -->
            <ng-container matColumnDef="MtxGridExpansionColumnDef">
              <td mat-cell *matCellDef="let row; let dataIndex = dataIndex"
                [attr.colspan]="displayedColumns.length">
                <div class="mtx-grid-expansion-detail"
                  [@expansion]="expansionRowStates[dataIndex].expanded ? 'expanded' : 'collapsed'">
                  <ng-template [ngTemplateOutlet]="expansionTemplate"
                    [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: dataIndex, expanded: expansionRowStates[dataIndex].expanded }">
                  </ng-template>
                </div>
              </td>
            </ng-container>
            <tr mat-row
              *matRowDef="let row; columns: ['MtxGridExpansionColumnDef']; let dataIndex = dataIndex"
              class="mtx-grid-expansion"
              [class]="expansionRowStates[dataIndex].expanded ? 'expanded' : 'collapsed'">
            </tr>
          }
        </table>
      } @else {
        <!-- TODO: Use flexbox-based mat-table -->
        <table mat-table
          columnResize
          [class]="{'mat-table-hover': rowHover, 'mat-table-striped': rowStriped, 'mat-table-expandable': expandable}"
          [dataSource]="dataSource" [multiTemplateDataRows]="expandable"
          matSort
          [matSortActive]="sortActive"
          [matSortDirection]="sortDirection"
          [matSortDisableClear]="sortDisableClear"
          [matSortDisabled]="sortDisabled"
          [matSortStart]="sortStart"
          (matSortChange)="_onSortChange($event)"
          [trackBy]="trackBy">
          @if (rowSelectable && !hideRowSelectionCheckbox) {
            <ng-container matColumnDef="MtxGridCheckboxColumnDef">
              <th mat-header-cell *matHeaderCellDef class="mtx-grid-checkbox-cell">
                @if (multiSelectable) {
                  <mat-checkbox
                    [checked]="rowSelection.hasValue() && _isAllSelected()"
                    [indeterminate]="rowSelection.hasValue() && !_isAllSelected()"
                    (change)="$event ? _toggleMasterCheckbox() : null">
                  </mat-checkbox>
                }
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                class="mtx-grid-checkbox-cell">
                @if (!(rowSelectionFormatter.hideCheckbox && rowSelectionFormatter.hideCheckbox(row, _getIndex(index, dataIndex)))) {
                  <mat-checkbox
                    [disabled]="rowSelectionFormatter.disabled && rowSelectionFormatter.disabled(row, _getIndex(index, dataIndex))"
                    [checked]="rowSelection.isSelected(row)"
                    (click)="$event.stopPropagation()"
                    (change)="$event ? _toggleNormalCheckbox(row) : null">
                  </mat-checkbox>
                }
              </td>
              <td mat-footer-cell *matFooterCellDef class="mtx-grid-checkbox-cell"></td>
            </ng-container>
          }
          @for (col of columns; track col) {
            <ng-container [matColumnDef]="col.field"
              [sticky]="col.pinned==='left'" [stickyEnd]="col.pinned==='right'">
              <th mat-header-cell *matHeaderCellDef
                [class]="col | colClass"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style]="{'width': col.width, 'left': col.left, 'right': col.right}"
                [resizable]="col.resizable"
                [matResizableMinWidthPx]="col.minWidth" [matResizableMaxWidthPx]="col.maxWidth">
                <div class="mat-header-cell-inner">
                  @if (headerTemplate | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(headerTemplate)"
                      [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                    </ng-template>
                  } @else {
                    @if ($any(headerTemplate)?.[col.field] | isTemplateRef) {
                      <ng-template [ngTemplateOutlet]="$any(headerTemplate)[col.field]"
                        [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                      </ng-template>
                    } @else {
                      <div [mat-sort-header]="col.sortProp?.id || col.field"
                        [disabled]="!col.sortable"
                        [disableClear]="col.sortProp?.disableClear ?? sortDisableClear"
                        [arrowPosition]="col.sortProp?.arrowPosition!"
                        [start]="col.sortProp?.start!">
                        @if (col.showExpand) {
                          <span class="mtx-grid-expansion-placeholder"></span>
                        }
                        <span>{{col.header | toObservable | async}}</span>
                        @if (col.sortable) {
                          <svg class="mtx-grid-icon mat-sort-header-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z" />
                          </svg>
                        }
                      </div>
                      <ng-template [ngTemplateOutlet]="headerExtraTplBase"
                        [ngTemplateOutletContext]="{ $implicit: headerExtraTemplate, colDef: col }">
                      </ng-template>
                    }
                  }
                </div>
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                [class]="col | colClass: row: rowChangeRecord :rowChangeRecord?.currentValue"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style]="{'width': col.width, 'left': col.left, 'right': col.right}"
                mtx-grid-selectable-cell [cellSelectable]="cellSelectable"
                (cellSelectedChange)="_selectCell($event, row, col)">
                @if (cellTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(cellTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                  </ng-template>
                } @else {
                  @if ($any(cellTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(cellTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                    </ng-template>
                  } @else {
                    @if (col.cellTemplate) {
                      <ng-template
                        [ngTemplateOutlet]="col.cellTemplate!"
                        [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                      </ng-template>
                    } @else {
                      @if (col.showExpand) {
                        <button class="mtx-grid-row-expand-button"
                          mat-icon-button mtx-grid-expansion-toggle type="button"
                          [(opened)]="expansionRowStates[dataIndex].expanded"
                          (toggleChange)="_onExpansionChange($event, row, col, dataIndex);">
                          <svg class="mtx-grid-icon mtx-grid-row-expand-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
                          </svg>
                        </button>
                      }
                      <mtx-grid-cell [rowData]="row" [colDef]="col" [placeholder]="emptyValuePlaceholder"
                        (rowDataChange)="_onRowDataChange($event)"></mtx-grid-cell>
                    }
                  }
                }
              </td>
              <td mat-footer-cell *matFooterCellDef
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style]="{'width': col.width, 'left': col.left, 'right': col.right}">
                @if (col.showExpand) {
                  <span class="mtx-grid-expansion-placeholder"></span>
                }
                @if (summaryTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(summaryTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: col, colDef: col, data: data }">
                  </ng-template>
                } @else {
                  @if ($any(summaryTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(summaryTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: _getColData(data, col), colData: _getColData(data, col), colDef: col }">
                    </ng-template>
                  } @else {
                    <mtx-grid-cell [summary]="true" [data]="data" [colDef]="col"
                      [placeholder]="emptyValuePlaceholder"></mtx-grid-cell>
                  }
                }
              </td>
            </ng-container>
          }
          @if (!useContentHeaderRowTemplate) {
            <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (!useContentRowTemplate) {
            <tr mat-row
              *matRowDef="let row; let index = index; let dataIndex = dataIndex; columns: displayedColumns;"
              [class]="row | rowClass: index: dataIndex: rowClassFormatter"
              [class.selected]="rowSelection.isSelected(row)"
              (click)="_selectRow($event, row, _getIndex(index, dataIndex))"
              (contextmenu)="_contextmenu($event, row, _getIndex(index, dataIndex))">
            </tr>
          }
          @if (_whetherShowSummary) {
            <tr mat-footer-row *matFooterRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (expandable) {
            <!-- Expanded Content Column - The expandable row is made up of this one column that spans across all columns -->
            <ng-container matColumnDef="MtxGridExpansionColumnDef">
              <td mat-cell *matCellDef="let row; let dataIndex = dataIndex"
                [attr.colspan]="displayedColumns.length">
                <div class="mtx-grid-expansion-detail"
                  [@expansion]="expansionRowStates[dataIndex].expanded ? 'expanded' : 'collapsed'">
                  <ng-template [ngTemplateOutlet]="expansionTemplate"
                    [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: dataIndex, expanded: expansionRowStates[dataIndex].expanded }">
                  </ng-template>
                </div>
              </td>
            </ng-container>
            <tr mat-row
              *matRowDef="let row; columns: ['MtxGridExpansionColumnDef']; let dataIndex = dataIndex"
              class="mtx-grid-expansion"
              [class]="expansionRowStates[dataIndex].expanded ? 'expanded' : 'collapsed'">
            </tr>
          }
        </table>
      }
    </div>

    <!-- No result -->
    @if (_hasNoResult) {
      <div class="mtx-grid-no-result">
        @if (noResultTemplate) {
          <ng-template [ngTemplateOutlet]="noResultTemplate"></ng-template>
        } @else {
          {{noResultText}}
        }
      </div>
    }
  </div>

  <!-- Tool sidebar -->
  @if (showSidebar) {
    <div class="mtx-grid-sidebar">
      @if (sidebarTemplate) {
        <ng-template [ngTemplateOutlet]="sidebarTemplate"></ng-template>
      }
    </div>
  }
</div>

<div class="mtx-grid-footer">
  <!-- Status Bar -->
  @if (showStatusbar) {
    <div class="mtx-grid-statusbar">
      @if (statusbarTemplate) {
        <ng-template [ngTemplateOutlet]="statusbarTemplate"></ng-template>
      }
    </div>
  }

  <!-- Pagination -->
  <div class="mtx-grid-pagination">
    @if (paginationTemplate) {
      <ng-template [ngTemplateOutlet]="paginationTemplate"></ng-template>
    } @else {
      <mat-paginator [class.mat-paginator-hidden]="!showPaginator"
        [showFirstLastButtons]="showFirstLastButtons"
        [length]="length"
        [pageIndex]="pageIndex"
        [pageSize]="pageSize"
        [pageSizeOptions]="pageSizeOptions"
        [hidePageSize]="hidePageSize"
        (page)="_onPage($event)"
        [disabled]="pageDisabled">
      </mat-paginator>
    }
  </div>
</div>

<!-- Header template for extra content -->
<ng-template #headerExtraTplBase let-headerExtraTemplate let-col="colDef">
  @if (headerExtraTemplate | isTemplateRef) {
    <ng-template [ngTemplateOutlet]="headerExtraTemplate"
      [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
    </ng-template>
  } @else {
    @if ($any(headerExtraTemplate)?.[col.field] | isTemplateRef) {
      <ng-template [ngTemplateOutlet]="headerExtraTemplate[col.field]"
        [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
      </ng-template>
    }
  }
</ng-template>
`,
      styles: [".mtx-grid{position:relative;display:flex;flex-direction:column;width:100%;overflow:hidden;border:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant));border-radius:var(--mtx-grid-container-shape, var(--mat-app-corner-medium))}.mtx-grid .mat-mdc-table{--mat-table-row-item-outline-color: var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid .mat-mdc-table.mat-table-striped .mat-row-odd{background-color:var(--mtx-grid-table-row-striped-background-color, var(--mat-app-surface-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row:hover{background-color:var(--mtx-grid-table-row-hover-background-color, var(--mat-app-secondary-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row.selected:hover{background-color:var(--mtx-grid-table-row-selected-hover-background-color, var(--mat-app-primary-container))}.mtx-grid .mat-mdc-table .mat-mdc-row.selected{background-color:var(--mtx-grid-table-row-selected-background-color, var(--mat-app-secondary-container))}.mtx-grid .mat-mdc-table .mat-mdc-cell.selected{box-shadow:inset 0 0 0 1px var(--mtx-grid-table-cell-selected-outline-color, var(--mat-app-primary))}.mtx-grid .mat-table-container{overflow:auto}.mtx-grid .mat-table-container.mat-table-with-data{flex:1}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table){min-width:100%;border-collapse:separate}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-header-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-footer-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-cell:not(.mtx-grid-checkbox-cell){min-width:var(--mtx-grid-table-cell-min-width)}.mtx-grid .mat-table-sticky-left{border-right:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-left{border-right-width:0;border-left:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-table-sticky-right{border-left:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-right{border-left-width:0;border-right:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-mdc-footer-cell{border-top:1px solid var(--mat-table-row-item-outline-color);background-color:var(--mtx-grid-table-footer-background-color, var(--mat-app-surface-container))}.mtx-grid .mat-mdc-row.mtx-grid-expansion{height:0;overflow:hidden}.mtx-grid .mat-mdc-row.mtx-grid-expansion .mat-mdc-cell{padding-top:0;padding-bottom:0}.mtx-grid .mat-mdc-row.mtx-grid-expansion.collapsed .mat-mdc-cell{border-bottom-width:0}.mtx-grid .mat-sort-header-icon{margin:0 4px}.mtx-grid .mat-header-cell-inner{display:inline-flex;align-items:center;vertical-align:middle}.mtx-grid .mat-mdc-paginator{border-top:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant));border-bottom-left-radius:var(--mtx-grid-container-shape, var(--mat-app-corner-medium));border-bottom-right-radius:var(--mtx-grid-container-shape, var(--mat-app-corner-medium))}.mtx-grid .mat-paginator-hidden{display:none}.mtx-grid .mtx-grid-checkbox-cell{width:60px;min-width:60px;padding:0 calc((60px - var(--mdc-checkbox-state-layer-size)) / 2)}.mtx-grid-progress{position:absolute;top:0;z-index:120;width:100%}.mtx-grid-toolbar{display:flex;justify-content:space-between;align-items:center;min-height:var(--mat-table-header-container-height);padding:8px;box-sizing:border-box;border-bottom:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-toolbar-content{flex:1;width:0;padding:0 8px}.mtx-grid-layout{display:flex;flex:1 1 auto;overflow:auto}.mtx-grid-content{flex-direction:column;width:0}.mtx-grid-sidebar{max-width:50%;border-left:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}[dir=rtl] .mtx-grid-sidebar{border-left-width:0;border-right:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-footer{position:relative;z-index:1}.mtx-grid-statusbar{display:flex;align-items:center;min-height:var(--mat-table-header-container-height);padding:8px;box-sizing:border-box;border-top:1px solid var(--mtx-grid-outline-color, var(--mat-app-outline-variant))}.mtx-grid-no-result{display:flex;justify-content:center;align-items:center;flex:1;min-height:150px}.mtx-grid-expansion-placeholder{display:inline-block;vertical-align:middle;width:var(--mdc-icon-button-state-layer-size, var(var(--mtx-grid-row-expand-button-size)));height:var(--mdc-icon-button-state-layer-size, var(var(--mtx-grid-row-expand-button-size)))}.mtx-grid-expansion-detail{display:flex;align-items:center;min-height:var(--mat-table-row-item-container-height);overflow:hidden}.mtx-grid-row-expand-button.expanded .mtx-grid-row-expand-icon{transform:rotate(90deg)}.mtx-grid-row-expand-button.mat-mdc-icon-button,.mtx-grid-row-expand-button+mtx-grid-cell{vertical-align:middle}.mtx-grid-icon{width:20px;height:20px;font-size:20px}\n"]
    }]
  }], () => [{
    type: MtxGridUtils
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MTX_GRID_DEFAULT_OPTIONS]
    }]
  }], {
    table: [{
      type: ViewChild,
      args: [MatTable]
    }],
    paginator: [{
      type: ViewChild,
      args: [MatPaginator]
    }],
    sort: [{
      type: ViewChild,
      args: [MatSort]
    }],
    rowDefs: [{
      type: ContentChildren,
      args: [MatRowDef]
    }],
    headerRowDefs: [{
      type: ContentChildren,
      args: [MatHeaderRowDef]
    }],
    footerRowDefs: [{
      type: ContentChildren,
      args: [MatFooterRow]
    }],
    columnMenu: [{
      type: ViewChild,
      args: ["columnMenu"]
    }],
    tableContainer: [{
      type: ViewChild,
      args: ["tableContainer"]
    }],
    displayedColumns: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    length: [{
      type: Input
    }],
    loading: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    trackBy: [{
      type: Input
    }],
    columnResizable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    emptyValuePlaceholder: [{
      type: Input
    }],
    pageOnFront: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showPaginator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    pageDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showFirstLastButtons: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    pageIndex: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageSizeOptions: [{
      type: Input
    }],
    hidePageSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    page: [{
      type: Output
    }],
    paginationTemplate: [{
      type: Input
    }],
    sortOnFront: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortActive: [{
      type: Input
    }],
    sortDirection: [{
      type: Input
    }],
    sortDisableClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortStart: [{
      type: Input
    }],
    sortChange: [{
      type: Output
    }],
    rowHover: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowStriped: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowClick: [{
      type: Output
    }],
    rowContextMenu: [{
      type: Output
    }],
    expandable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    expansionTemplate: [{
      type: Input
    }],
    expansionChange: [{
      type: Output
    }],
    multiSelectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    multiSelectionWithClick: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowSelectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hideRowSelectionCheckbox: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableRowClickSelection: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowSelectionFormatter: [{
      type: Input
    }],
    rowClassFormatter: [{
      type: Input
    }],
    rowSelected: [{
      type: Input
    }],
    rowSelectedChange: [{
      type: Output
    }],
    cellSelectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cellSelectedChange: [{
      type: Output
    }],
    showToolbar: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    toolbarTitle: [{
      type: Input
    }],
    toolbarTemplate: [{
      type: Input
    }],
    columnHideable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnHideableChecked: [{
      type: Input
    }],
    columnSortable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnPinnable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnChange: [{
      type: Output
    }],
    columnPinOptions: [{
      type: Input
    }],
    showColumnMenuButton: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnMenuButtonText: [{
      type: Input
    }],
    columnMenuButtonType: [{
      type: Input
    }],
    columnMenuButtonColor: [{
      type: Input
    }],
    columnMenuButtonClass: [{
      type: Input
    }],
    columnMenuButtonIcon: [{
      type: Input
    }],
    showColumnMenuHeader: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnMenuHeaderText: [{
      type: Input
    }],
    columnMenuHeaderTemplate: [{
      type: Input
    }],
    showColumnMenuFooter: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnMenuFooterText: [{
      type: Input
    }],
    columnMenuFooterTemplate: [{
      type: Input
    }],
    noResultText: [{
      type: Input
    }],
    noResultTemplate: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    headerExtraTemplate: [{
      type: Input
    }],
    cellTemplate: [{
      type: Input
    }],
    useContentRowTemplate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    useContentHeaderRowTemplate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    useContentFooterRowTemplate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showSummary: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    summaryTemplate: [{
      type: Input
    }],
    showSidebar: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sidebarTemplate: [{
      type: Input
    }],
    showStatusbar: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    statusbarTemplate: [{
      type: Input
    }]
  });
})();
var MtxGridModule = class _MtxGridModule {
  static {
    this.ɵfac = function MtxGridModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MtxGridModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MtxGridModule,
      imports: [CommonModule, FormsModule, MatTableModule, MatSortModule, MatPaginatorModule, MatCheckboxModule, MatButtonModule, MatProgressBarModule, MatChipsModule, MatTooltipModule, MatBadgeModule, MatIconModule, MatSelectModule, MatFormFieldModule, MatMenuModule, DragDropModule, MtxDialogModule, MtxPipesModule, MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe],
      exports: [MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [MtxGridUtils],
      imports: [CommonModule, FormsModule, MatTableModule, MatSortModule, MatPaginatorModule, MatCheckboxModule, MatButtonModule, MatProgressBarModule, MatChipsModule, MatTooltipModule, MatBadgeModule, MatIconModule, MatSelectModule, MatFormFieldModule, MatMenuModule, DragDropModule, MtxDialogModule, MtxPipesModule, MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MatColumnResizeModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, MatTableModule, MatSortModule, MatPaginatorModule, MatCheckboxModule, MatButtonModule, MatProgressBarModule, MatChipsModule, MatTooltipModule, MatBadgeModule, MatIconModule, MatSelectModule, MatFormFieldModule, MatMenuModule, DragDropModule, MtxDialogModule, MtxPipesModule, MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe],
      exports: [MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe],
      providers: [MtxGridUtils]
    }]
  }], null, null);
})();
export {
  AbstractMatColumnResize,
  AbstractMatResizable,
  FLEX_HOST_BINDINGS as MAT_FLEX_HOST_BINDINGS,
  FLEX_PROVIDERS2 as MAT_FLEX_PROVIDERS,
  FLEX_RESIZE_STRATEGY_PROVIDER2 as MAT_FLEX_RESIZE_STRATEGY_PROVIDER,
  RESIZABLE_HOST_BINDINGS as MAT_RESIZABLE_HOST_BINDINGS,
  RESIZABLE_INPUTS as MAT_RESIZABLE_INPUTS,
  TABLE_HOST_BINDINGS as MAT_TABLE_HOST_BINDINGS,
  TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER as MAT_TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER,
  TABLE_PROVIDERS2 as MAT_TABLE_PROVIDERS,
  MTX_GRID_DEFAULT_OPTIONS,
  MatColumnResize,
  MatColumnResizeCommonModule,
  MatColumnResizeFlex,
  MatColumnResizeModule,
  MatColumnResizeOverlayHandle,
  MatFlexTableResizeStrategy,
  MatResizable,
  MtxGrid,
  MtxGridCell,
  MtxGridCellActionBadgePipe,
  MtxGridCellActionDisablePipe,
  MtxGridCellActionTooltipPipe,
  MtxGridCellActionsPipe,
  MtxGridCellSummaryPipe,
  MtxGridColClassPipe,
  MtxGridColumnMenu,
  MtxGridExpansionToggle,
  MtxGridModule,
  MtxGridRowClassPipe,
  MtxGridSelectableCell,
  MtxGridUtils
};
/*! Bundled license information:

@ng-matero/extensions/fesm2022/mtxColumnResize.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@ng-matero/extensions/fesm2022/mtxGrid.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
*/
//# sourceMappingURL=@ng-matero_extensions_grid.js.map
