{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ngx-file-upload/core/fesm2022/ngx-file-upload-core.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { NgModule, InjectionToken, inject } from '@angular/core';\nimport { HttpClientModule, HttpHeaders, HttpEventType, HttpClient } from '@angular/common/http';\nimport { Subject, of, concat, merge, ReplaySubject, timer } from 'rxjs';\nimport { filter, tap, switchMap, bufferCount, map, takeUntil, take, distinctUntilKeyChanged } from 'rxjs/operators';\nclass NgxFileUploadCoreModule {\n  /** @nocollapse */static {\n    this.ɵfac = function NgxFileUploadCoreModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxFileUploadCoreModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxFileUploadCoreModule,\n      imports: [HttpClientModule]\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [HttpClientModule]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxFileUploadCoreModule, [{\n    type: NgModule,\n    args: [{\n      imports: [HttpClientModule]\n    }]\n  }], null, null);\n})();\nvar NgxFileUploadState;\n(function (NgxFileUploadState) {\n  NgxFileUploadState[NgxFileUploadState[\"INVALID\"] = 0] = \"INVALID\";\n  NgxFileUploadState[NgxFileUploadState[\"CANCELED\"] = 1] = \"CANCELED\";\n  NgxFileUploadState[NgxFileUploadState[\"IDLE\"] = 2] = \"IDLE\";\n  NgxFileUploadState[NgxFileUploadState[\"PENDING\"] = 3] = \"PENDING\";\n  NgxFileUploadState[NgxFileUploadState[\"START\"] = 4] = \"START\";\n  NgxFileUploadState[NgxFileUploadState[\"PROGRESS\"] = 5] = \"PROGRESS\";\n  NgxFileUploadState[NgxFileUploadState[\"COMPLETED\"] = 6] = \"COMPLETED\";\n})(NgxFileUploadState || (NgxFileUploadState = {}));\nclass NgxFileUploadFile {\n  constructor(file) {\n    this.validationErrors = null;\n    this.raw = file;\n    this.size = file.size;\n    this.type = file.type;\n    this.name = file.name;\n  }\n}\n\n/**\r\n * Represents an upload request, and store the data inside\r\n */\nclass NgxFileUploadRequestModel {\n  constructor(file) {\n    this.filesToUpload = [];\n    this.response = {\n      body: null,\n      errors: null,\n      success: false\n    };\n    this.state = NgxFileUploadState.IDLE;\n    this.uploaded = 0;\n    this.progress = 0;\n    this.hasError = false;\n    this.filesToUpload = !Array.isArray(file) ? [file] : file;\n  }\n  get files() {\n    return this.filesToUpload;\n  }\n  get name() {\n    return this.files.map(file => file.name);\n  }\n  get size() {\n    return this.files.reduce((size, file) => size + file.size, 0);\n  }\n  get validationErrors() {\n    const validationErrors = this.files.reduce((errors, file) => {\n      if (file.validationErrors) {\n        errors[file.name] = {\n          ...file.validationErrors\n        };\n      }\n      return errors;\n    }, {});\n    return Object.keys(validationErrors).length ? validationErrors : null;\n  }\n  toJson() {\n    return {\n      files: this.files,\n      hasError: this.hasError,\n      name: this.name,\n      progress: this.progress,\n      response: this.response,\n      size: this.size,\n      state: this.state,\n      uploaded: this.uploaded,\n      validationErrors: this.validationErrors\n    };\n  }\n}\nclass NgxFileUploadRequest {\n  get change() {\n    return this.change$.asObservable();\n  }\n  get destroyed() {\n    return this.destroyed$.asObservable();\n  }\n  get data() {\n    return this.model.toJson();\n  }\n  set state(state) {\n    this.model.state = state;\n  }\n  get state() {\n    return this.model.state;\n  }\n  constructor(http, files, options) {\n    this.http = http;\n    this.cancel$ = new Subject();\n    this.change$ = new Subject();\n    this.destroyed$ = new Subject();\n    this.totalSize = -1;\n    this.options = {\n      url: \"\",\n      formData: {\n        enabled: true,\n        name: \"file\"\n      },\n      withCredentials: false\n    };\n    this.hooks = {\n      beforeStart: []\n    };\n    this.requestId = \"\";\n    this.model = new NgxFileUploadRequestModel(files);\n    this.state = this.isInvalid() ? NgxFileUploadState.INVALID : NgxFileUploadState.IDLE;\n    this.options = {\n      ...this.options,\n      ...options\n    };\n  }\n  beforeStart(hook) {\n    this.hooks.beforeStart = [...this.hooks.beforeStart, hook];\n  }\n  /**\r\n   * cancel current file upload, this will complete change subject\r\n   */\n  cancel() {\n    if (this.isProgress() || this.isPending()) {\n      this.model.state = NgxFileUploadState.CANCELED;\n      this.notifyObservers();\n      this.cancel$.next(true);\n    }\n  }\n  destroy() {\n    this.finalizeUpload();\n    this.destroyed$.next(true);\n    this.destroyed$.complete();\n  }\n  /**\r\n   * return true if upload was not completed since the server\r\n   * sends back an error response\r\n   */\n  hasError() {\n    return this.model.state === NgxFileUploadState.COMPLETED && !this.model.response?.success;\n  }\n  isCompleted(ignoreError = false) {\n    let isCompleted = this.isRequestCompleted();\n    isCompleted = isCompleted && (ignoreError || !this.hasError());\n    isCompleted = isCompleted || this.model.state === NgxFileUploadState.CANCELED;\n    return isCompleted;\n  }\n  isCanceled() {\n    return this.model.state === NgxFileUploadState.CANCELED;\n  }\n  isInvalid() {\n    return this.state === NgxFileUploadState.INVALID || this.model.validationErrors !== null;\n  }\n  isProgress() {\n    return this.state === NgxFileUploadState.PROGRESS || this.state === NgxFileUploadState.START;\n  }\n  isPending() {\n    return this.state === NgxFileUploadState.PENDING;\n  }\n  isIdle() {\n    return this.state === NgxFileUploadState.IDLE;\n  }\n  isRequestCompleted() {\n    return this.state === NgxFileUploadState.COMPLETED;\n  }\n  /**\r\n   * restart download again\r\n   * reset state, and reset errors\r\n   */\n  retry() {\n    if (this.isRequestCompleted() && this.hasError() || this.isCanceled()) {\n      this.model = new NgxFileUploadRequestModel(this.model.files);\n      this.start();\n    }\n  }\n  /**\r\n   * start file upload\r\n   */\n  start() {\n    if (!this.isIdle() && !this.isPending()) {\n      return;\n    }\n    this.beforeStartHook$.pipe(filter(isAllowedToStart => isAllowedToStart), tap(() => (this.model.state = NgxFileUploadState.START, this.notifyObservers())), switchMap(() => this.startUploadRequest())).subscribe({\n      next: event => this.handleHttpEvent(event),\n      error: error => this.handleError(error)\n    });\n  }\n  removeInvalidFiles() {\n    if (this.state !== NgxFileUploadState.INVALID) {\n      return;\n    }\n    const files = this.data.files.filter(file => file.validationErrors === null);\n    if (files.length) {\n      this.model = new NgxFileUploadRequestModel(files);\n      this.state = NgxFileUploadState.IDLE;\n      this.notifyObservers();\n    } else {\n      this.destroy();\n    }\n  }\n  /**\r\n   * call hooks in order, see playground\r\n   * @see https://rxviz.com/v/58GkkYv8\r\n   */\n  get beforeStartHook$() {\n    const initialState = this.model.state;\n    let hook$ = of(true);\n    if (this.hooks.beforeStart.length) {\n      hook$ = concat(...this.hooks.beforeStart).pipe(bufferCount(this.hooks.beforeStart.length), map(result => result.every(isAllowed => isAllowed)), tap(() => this.model.state !== initialState ? this.notifyObservers() : void 0));\n    }\n    return hook$;\n  }\n  /**\r\n   * build form data and send request to server\r\n   */\n  startUploadRequest() {\n    const uploadBody = this.createUploadBody();\n    const headers = this.createUploadHeaders();\n    /**\r\n     * save size on start so we do not call it every time\r\n     * since this running a reduce loop, and the size will not change\r\n     * anymore after we start it\r\n     */\n    this.totalSize = this.model.size;\n    return this.http.post(this.options.url, uploadBody, {\n      reportProgress: true,\n      withCredentials: this.options.withCredentials,\n      observe: \"events\",\n      headers\n    }).pipe(takeUntil(merge(this.cancel$, this.destroyed$)));\n  }\n  /**\r\n   * create upload body which will should be send\r\n   */\n  createUploadBody() {\n    if (this.options.formData?.enabled) {\n      const formDataOptions = this.options.formData;\n      const formData = new FormData();\n      const label = formDataOptions.name ?? 'fileupload';\n      this.model.files.forEach(file => {\n        formData.append(label, file.raw, file.name);\n      });\n      const additionalData = formDataOptions.additionalData;\n      if (additionalData && Object.keys(additionalData).length > 0) {\n        for (let [key, value] of Object.entries(additionalData)) {\n          formData.append(key, value);\n        }\n      }\n      if (formDataOptions.metadata) {\n        formData.append('metadata', JSON.stringify(formDataOptions.metadata));\n      }\n      return formData;\n    }\n    return this.model.files[0].raw;\n  }\n  /**\r\n   * create upload request headers\r\n   */\n  createUploadHeaders() {\n    if (this.options.headers) {\n      let headers = new HttpHeaders();\n      if (this.options.headers.authorization) {\n        headers = this.createAuthroizationHeader(headers);\n      }\n      /** add additional headers which should send */\n      Object.keys(this.options.headers).filter(header => header !== \"authorization\").forEach(header => headers = headers.append(header, this.options.headers?.[header]));\n      return headers;\n    }\n    return void 0;\n  }\n  /**\r\n   * create authorization header which will send\r\n   */\n  createAuthroizationHeader(headers) {\n    const authHeader = this.options.headers?.authorization;\n    if (authHeader) {\n      if (typeof authHeader === \"string\") {\n        headers = headers.append(\"Authorization\", `Bearer ${authHeader}`);\n      } else {\n        headers = headers.append(\"Authorization\", `${authHeader.key || \"Bearer\"} ${authHeader.token}`);\n      }\n    }\n    return headers;\n  }\n  /**\r\n   * request responds with an error\r\n   */\n  handleError(response) {\n    let errors = response.error instanceof ProgressEvent || response.status === 404 ? response.message : response.error;\n    errors = Array.isArray(errors) ? errors : [errors];\n    const uploadResponse = {\n      success: false,\n      body: null,\n      errors\n    };\n    this.model.state = NgxFileUploadState.COMPLETED;\n    this.model.response = uploadResponse;\n    this.model.hasError = true;\n    this.notifyObservers();\n  }\n  /**\r\n   * handle all http events\r\n   */\n  handleHttpEvent(event) {\n    switch (event.type) {\n      case HttpEventType.UploadProgress:\n        this.handleProgress(event);\n        break;\n      case HttpEventType.Response:\n        this.handleResponse(event);\n        break;\n    }\n  }\n  /**\r\n   * handle http progress event\r\n   */\n  handleProgress(event) {\n    const loaded = event.loaded;\n    const progress = loaded * 100 / this.totalSize;\n    this.model.state = NgxFileUploadState.PROGRESS;\n    /**\r\n     * for some reason the upload is sometimes a bit bigger then the files,\r\n     * pretty sure this happens because of headers which are send makes the request a bit\r\n     * bigger\r\n     */\n    this.model.uploaded = Math.min(loaded, this.totalSize);\n    this.model.progress = Math.min(Math.round(progress), 100);\n    this.notifyObservers();\n  }\n  /**\r\n   * upload completed with an success\r\n   */\n  handleResponse(res) {\n    const uploadResponse = {\n      success: res.ok,\n      body: res.body,\n      errors: null\n    };\n    this.model.response = uploadResponse;\n    this.model.state = NgxFileUploadState.COMPLETED;\n    this.notifyObservers();\n    this.finalizeUpload();\n  }\n  /**\r\n   * send notification to observers\r\n   */\n  notifyObservers() {\n    this.change$.next(this.data);\n  }\n  /**\r\n   * upload has been completed, canceled or destroyed\r\n   */\n  finalizeUpload() {\n    this.change$.complete();\n    this.cancel$.complete();\n  }\n}\n\n/**\r\n * Factory to create upload requests\r\n */\nclass Factory {\n  /**\r\n   * construct upload factory\r\n   */\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  createUploadRequest(file, options, validator) {\n    const files = Array.isArray(file) ? file : [file];\n    if (files.length) {\n      const fileModels = files.map(file => {\n        const model = new NgxFileUploadFile(file);\n        if (validator) {\n          model.validationErrors = \"validate\" in validator ? validator.validate(file) : validator(file);\n        }\n        return model;\n      });\n      // * create one requests which holds all files\n      return new NgxFileUploadRequest(this.httpClient, fileModels, options);\n    }\n    return null;\n  }\n}\n/**\r\n * InjectionToken for NgxFileuploadFactory\r\n */\nconst NgxFileUploadFactory = new InjectionToken(\"Ngx Fileupload Factory\", {\n  providedIn: \"root\",\n  factory: () => new Factory(inject(HttpClient))\n});\nclass NgxFileUploadQueue {\n  constructor() {\n    this.active = 0;\n    this.queuedUploads = [];\n    this.concurrentCount = -1;\n    this.observedUploads = new WeakSet();\n  }\n  set concurrent(count) {\n    this.concurrentCount = count;\n  }\n  register(upload) {\n    upload.beforeStart(this.createBeforeStartHook(upload));\n  }\n  /**\r\n   * create before start hook, if any upload wants to start we have to check\r\n   */\n  createBeforeStartHook(request) {\n    return of(true).pipe(\n    /**\r\n     * before any download starts we registers on it\r\n     * to get notified when it starts and when it is completed, destroyed\r\n     */\n    tap(() => this.registerUploadChange(request)),\n    /**\r\n     * check active uploads and max uploads we could run\r\n     */\n    map(() => this.active < this.concurrentCount),\n    /**\r\n     * if we could not start upload push it into queue\r\n     */\n    tap(isStartAble => {\n      if (!isStartAble) {\n        this.writeToQueue(request);\n      }\n    }));\n  }\n  /**\r\n   * register to upload change\r\n   */\n  registerUploadChange(request) {\n    if (!this.observedUploads.has(request)) {\n      this.observedUploads.add(request);\n      const change$ = request.change;\n      /** register for changes which make request complete */\n      const uploadComplete$ = change$.pipe(filter(() => request.isCompleted(true)), take(1));\n      change$.pipe(filter(data => data.state === NgxFileUploadState.START), takeUntil(merge(request.destroyed, uploadComplete$))).subscribe({\n        next: () => this.active += 1,\n        complete: () => {\n          this.requestCompleted(request);\n        }\n      });\n    }\n  }\n  writeToQueue(request) {\n    request.state = NgxFileUploadState.PENDING;\n    this.queuedUploads = [...this.queuedUploads, request];\n  }\n  /**\r\n   * requests gets completed, this means request is pending or was progressing and the user\r\n   * cancel request, remove it or even destroys them\r\n   */\n  requestCompleted(request) {\n    this.isInUploadQueue(request) ? this.removeFromQueue(request) : this.startNextInQueue();\n    this.observedUploads.delete(request);\n  }\n  /**\r\n   * checks upload is in queue\r\n   */\n  isInUploadQueue(request) {\n    return this.queuedUploads.indexOf(request) > -1;\n  }\n  /**\r\n   * remove upload request from queued uploads\r\n   */\n  removeFromQueue(request) {\n    this.queuedUploads = this.queuedUploads.filter(upload => upload !== request);\n  }\n  /**\r\n   * try to start next upload in queue, returns false if no further uploads\r\n   * exists\r\n   */\n  startNextInQueue() {\n    this.active = Math.max(this.active - 1, 0);\n    if (this.queuedUploads.length > 0) {\n      const nextUpload = this.queuedUploads.shift();\n      nextUpload.start();\n    }\n  }\n}\nconst defaultStoreConfig = {\n  concurrentUploads: 5,\n  autoStart: false\n};\nclass NgxFileUploadStorage {\n  constructor(config) {\n    this.uploads = new Map();\n    this.destroyed$ = new Subject();\n    this.bulkProcess = [];\n    this.change$ = new ReplaySubject(1);\n    this.uploadQueue = new NgxFileUploadQueue();\n    this.storeConfig = {\n      ...defaultStoreConfig,\n      ...(config || {})\n    };\n    this.uploadQueue.concurrent = this.storeConfig.concurrentUploads;\n  }\n  /**\r\n   * submits if any upload changes his state, uploads\r\n   * gets removed or added\r\n   */\n  change() {\n    return this.change$;\n  }\n  /**\r\n   * add new upload to store\r\n   */\n  add(upload) {\n    const requests = Array.isArray(upload) ? upload : [upload];\n    requests.forEach(request => {\n      if (request.requestId && this.uploads.has(request.requestId)) {\n        return;\n      }\n      request.requestId = request.requestId || this.generateUniqeRequestId();\n      this.uploads.set(request.requestId, request);\n      this.registerUploadEvents(request);\n    });\n    this.afterUploadsAdd(requests);\n    this.notifyObserver();\n  }\n  destroy() {\n    /** remove from all subscriptions */\n    this.destroyed$.next(true);\n    /** stop all downloads */\n    this.stopAll();\n    /** destroy change stream */\n    this.destroyed$.complete();\n    this.change$.complete();\n  }\n  remove(upload) {\n    const id = typeof upload === \"string\" ? upload : upload.requestId;\n    const request = this.uploads.get(id);\n    request?.destroy();\n  }\n  purge() {\n    let notify = false;\n    this.uploads.forEach(request => {\n      if (request.isCompleted() || request.isInvalid()) {\n        this.bulkProcess.push(request.requestId);\n        notify = true;\n        request.destroy();\n      }\n    });\n    if (notify) {\n      this.notifyObserver();\n    }\n  }\n  startAll() {\n    this.uploads.forEach(upload => {\n      if (upload.isIdle()) {\n        this.bulkProcess.push(upload.requestId);\n        upload.start();\n      }\n    });\n    this.notifyObserver();\n  }\n  stopAll() {\n    this.uploads.forEach(upload => {\n      this.bulkProcess.push(upload.requestId);\n      upload.destroy();\n    });\n    this.notifyObserver();\n  }\n  removeInvalid() {\n    this.uploads.forEach(upload => {\n      if (upload.isInvalid()) {\n        this.bulkProcess.push(upload.requestId);\n        upload.destroy();\n      }\n    });\n    this.notifyObserver();\n  }\n  registerUploadEvents(request) {\n    if (!request.isInvalid()) {\n      this.queueRequest(request);\n    } else {\n      request.change.pipe(filter(data => data.state === NgxFileUploadState.IDLE), take(1), takeUntil(request.destroyed)).subscribe(() => {\n        this.queueRequest(request);\n        this.notifyObserver();\n      });\n    }\n    request.destroyed.pipe(tap(() => this.uploads.delete(request.requestId)), take(1)).subscribe(() => this.isBulkProcess(request) ? this.removeBulkProcess(request) : this.notifyObserver());\n  }\n  queueRequest(request) {\n    this.uploadQueue.register(request);\n    this.handleRequestChange(request);\n  }\n  /**\r\n   * @description register to request change events, this will notify all observers\r\n   * if state from upload state has been changed, this will not notify\r\n   * if amount of uploaded size has been changed\r\n   */\n  handleRequestChange(request) {\n    const isAutoRemove = !!(this.storeConfig.removeCompleted ?? 0);\n    request.change.pipe(distinctUntilKeyChanged(\"state\"), tap(() => /** do not notify if bulk process */{\n      this.isBulkProcess(request) ? this.removeBulkProcess(request) : this.notifyObserver();\n    }), /* only continue if completed with no errors and autoremove is enabled */\n    filter(() => request.data.state === NgxFileUploadState.COMPLETED && !request.hasError() && isAutoRemove), /** wait for given amount of time before we remove item */\n    switchMap(() => timer(this.storeConfig.removeCompleted ?? 0)), /* automatically unsubscribe if request gets destroyed */\n    takeUntil(request.destroyed)).subscribe(() => this.remove(request));\n  }\n  afterUploadsAdd(requests) {\n    if (this.storeConfig.autoStart) {\n      requests.forEach(uploadRequest => uploadRequest.start());\n    }\n  }\n  generateUniqeRequestId() {\n    let reqId;\n    do {\n      reqId = Array.from({\n        length: 4\n      }, () => Math.random().toString(32).slice(2)).join(\"-\");\n    } while (this.uploads.has(reqId));\n    return reqId;\n  }\n  notifyObserver() {\n    this.change$.next(Array.from(this.uploads.values()));\n  }\n  removeBulkProcess(request) {\n    this.bulkProcess = this.bulkProcess.filter(id => request.requestId !== id);\n  }\n  isBulkProcess(request) {\n    return this.bulkProcess.indexOf(request.requestId) > -1;\n  }\n}\nclass NgxFileUploadGroupedvalidator {\n  constructor(validators) {\n    this.validators = Array.isArray(validators) ? validators : [];\n  }\n  /**\r\n   * add validators\r\n   */\n  add(...validators) {\n    this.validators = this.validators.concat(validators);\n  }\n  /**\r\n   * clean up all validators\r\n   */\n  clean() {\n    this.validators = [];\n  }\n  /**\r\n   * executes validator and returns validation result\r\n   */\n  execValidator(validator, file) {\n    /** we handle a validator class directly */\n    if (\"validate\" in validator) {\n      return validator.validate(file);\n    }\n    /** we handle a validation function */\n    return validator(file);\n  }\n}\nclass NgxFileUploadAndValidator extends NgxFileUploadGroupedvalidator {\n  validate(file) {\n    const validationResult = {};\n    let hasErrors = false;\n    for (const validator of this.validators) {\n      const result = this.execValidator(validator, file);\n      if (result !== null) {\n        Object.assign(validationResult, result);\n        hasErrors = true;\n      }\n    }\n    return hasErrors ? validationResult : null;\n  }\n}\nclass NgxFileUploadOrValidator extends NgxFileUploadGroupedvalidator {\n  validate(file) {\n    let validationResult = {};\n    for (const validator of this.validators) {\n      const result = this.execValidator(validator, file);\n      if (result === null) {\n        validationResult = null;\n        break;\n      }\n      Object.assign(validationResult, result);\n    }\n    return validationResult;\n  }\n}\nclass NgxFileUploadValidationBuilder {\n  static and(...validators) {\n    return new NgxFileUploadAndValidator(validators);\n  }\n  static or(...validators) {\n    return new NgxFileUploadOrValidator(validators);\n  }\n}\n\n/*\r\n * Public API Surface of core\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { NgxFileUploadAndValidator, NgxFileUploadCoreModule, NgxFileUploadFactory, NgxFileUploadFile, NgxFileUploadGroupedvalidator, NgxFileUploadOrValidator, NgxFileUploadQueue, NgxFileUploadRequest, NgxFileUploadState, NgxFileUploadStorage, NgxFileUploadValidationBuilder };\n"],
  "mappings": "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",
  "names": ["NgxFileUploadState", "file"]
}
